# 8 Query Performance Optimization
MySQL如何执行查询,以及推理出query的效率.

query不好,再好的schema和indexes页没用.
query,index,schema优化三者紧密联系,时不时回头看前两章.
query的不好要先考虑的事情->Mysql如何执行query,如何改变执行计划->Mysql没用优化的query,探索query优化的模式.
帮助你深入理解MySQL执行查询,这样可以推理query的高效/低效.

## Why Are Queries Slow?
query由subtasks组成,想优化query,减少subtasks(发生更少次,更快).
查询序列图: client->Server. (where parsed, planned, executed)
network, CPU, operations(statistics, planning, locking, retrieve rows), I/O
一般是operations不需要,重复,太慢,优化就是优化掉它们.

## Slow Query Basics: Optimize Data Access
1. 是不是查了自己不需要的数据. 比如太多行,或者太多列
2. MySQL server是不是分析了不需要的列

### Are you asking the Database for Data you don't need?
- Fetching more rows than needed: 加limit,需要多少行就返回多少行
- Fetching all columns from a multitable join: 连表时,别用*返回所有表的字段
- Fetching all columns: 对*时刻保持警惕.但是有缓存时,确实可以用*.
- Fetching the same data repeatedly: 经常重复查同一数据,可以缓存下

### Is MySQL Examining Too Much Data?
query metrics: 全部都在慢查询日志里
- Response time
- Number of rows examined
- Number of rows returned
#### Response time
查询时间最好按第一次的来.
Response time: 分为service time(执行查询时间), queue time(等待IO, 等待锁) 这部分是性能最大的影响部分.
因此Response time 因为环境不同,queue time也不同,差异很大.
如何评估queue time? 预估需要的顺序IO和随机IO * 需要硬件的时间,对比实际的时间.

#### Rows examined and rows returned
需要检视的行数很有用.少的行数要快,但是存储在内存比硬盘中的要快.
理想情况下,检视的行和返回的行数相同.实际上连表时,返回的行数比检视的行数少很多.

#### Rows examined and access types
查询单行,有时候会examine很多行,有时候不用examine行.
scanning a table, scanning an index, range accesses, and single-value accesses
如果访问类型差,那么可能需要加索引.索引之所以重要,是因为可以让MySQLexamine更少的行.
MySQL应用Where的三种情况:
1. 用索引去掉不匹配的行,在引擎层
2. 用覆盖索引避免访问行,在获取索引的全部数据后,过滤掉不匹配的行,在Server层.Extra Using index
3. 从行中获取所有数据,然后过滤.Extra Using where
-----
如果你发现examine要远大于return
- 使用覆盖索引,storage engine不必返回所有行
- 改变schema, 使用Summary tables(第六章)
- 重写复杂查询


## Ways to Restructure Queries
优化SQL时,找替代的方法获得你想要的结果,但是从MySQL的结果集不一定非要一样.

### Complex Queries Versus Many Queries
之前认为复合查询比多个查询好,因为网络交流和查询转化和优化阶段的消耗.
现在MySQL QPS高,而且网络也比以前好,多个查询不是什么坏事.
MySQL内部还是比网络快,但是如果分解查询能比复合查询好,就分解.

### Chopping Up a Query
批量删除时,每次delete10000行.
因为一次性清除大量数据,会长时间锁很多行,塞满事务日志, 资源耗尽,阻塞小查询.

### Join Decomposition
分解join的好处:
-- select * from tag where tag = 'mysql';
-- select * from tag_post where  tag_id=1234;
-- select * from post where post.id in (123,456,567,9098,8904);
- 缓存更高效. 比如第一条可能已经缓存了.再比如缓存了9098,8904,可以只查前三.
- 单独查表,可以减少锁表的情况.
- 更容易分库分表
- in比连表更快.
- 减少获取的重复数据,减少网络和内存使用.

## Query Execution Basics
1. client -> server(SQL statement)
2. server parses, preprocesses, and optimizes into query execution plan
3. query execution engine executes the plan by calling the storage engine API
4. the server sends the result to the client
 
### The MySQL Client/Server Protocol

### Query States

### The Query Optimization Process

### The Query Execution Engine

### Returning Results to the Client

## Limitations of the MySQL Query Optimizer

## Optimizing Specific Types of Queries

## Summary
stop doing things, do them fewer times, do them more quickly
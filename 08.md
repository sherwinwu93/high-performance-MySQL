# 8 Query Performance Optimization
MySQL如何执行查询,以及推理出query的效率.

query不好,再好的schema和indexes页没用.
query,index,schema优化三者紧密联系,时不时回头看前两章.
query的不好要先考虑的事情->Mysql如何执行query,如何改变执行计划->Mysql没用优化的query,探索query优化的模式.
帮助你深入理解MySQL执行查询,这样可以推理query的高效/低效.

## Why Are Queries Slow?
query由subtasks组成,想优化query,减少subtasks(发生更少次,更快).
查询序列图: client->Server. (where parsed, planned, executed)
network, CPU, operations(statistics, planning, locking, retrieve rows), I/O
一般是operations不需要,重复,太慢,优化就是优化掉它们.

## Slow Query Basics: Optimize Data Access
1. 是不是查了自己不需要的数据. 比如太多行,或者太多列
2. MySQL server是不是分析了不需要的列

### Are you asking the Database for Data you don't need?
- Fetching more rows than needed: 加limit,需要多少行就返回多少行
- Fetching all columns from a multitable join: 连表时,别用*返回所有表的字段
- Fetching all columns: 对*时刻保持警惕.但是有缓存时,确实可以用*.
- Fetching the same data repeatedly: 经常重复查同一数据,可以缓存下

### Is MySQL Examining Too Much Data?
query metrics: 全部都在慢查询日志里
- Response time
- Number of rows examined
- Number of rows returned
#### Response time
查询时间最好按第一次的来.
Response time: 分为service time(执行查询时间), queue time(等待IO, 等待锁) 这部分是性能最大的影响部分.
因此Response time 因为环境不同,queue time也不同,差异很大.
如何评估queue time? 预估需要的顺序IO和随机IO * 需要硬件的时间,对比实际的时间.

#### Rows examined and rows returned
需要检视的行数很有用.少的行数要快,但是存储在内存比硬盘中的要快.
理想情况下,检视的行和返回的行数相同.实际上连表时,返回的行数比检视的行数少很多.

#### Rows examined and access types
查询单行,有时候会examine很多行,有时候不用examine行.
scanning a table, scanning an index, range accesses, and single-value accesses
如果访问类型差,那么可能需要加索引.索引之所以重要,是因为可以让MySQLexamine更少的行.
MySQL应用Where的三种情况:
1. 用索引去掉不匹配的行,在引擎层
2. 用覆盖索引避免访问行,在获取索引的全部数据后,过滤掉不匹配的行,在Server层.Extra Using index
3. 从行中获取所有数据,然后过滤.Extra Using where
-----
如果你发现examine要远大于return
- 使用覆盖索引,storage engine不必返回所有行
- 改变schema, 使用Summary tables(第六章)
- 重写复杂查询


## Ways to Restructure Queries
优化SQL时,找替代的方法获得你想要的结果,但是从MySQL的结果集不一定非要一样.

### Complex Queries Versus Many Queries
之前认为复合查询比多个查询好,因为网络交流和查询转化和优化阶段的消耗.
现在MySQL QPS高,而且网络也比以前好,多个查询不是什么坏事.
MySQL内部还是比网络快,但是如果分解查询能比复合查询好,就分解.

### Chopping Up a Query
批量删除时,每次delete10000行.
因为一次性清除大量数据,会长时间锁很多行,塞满事务日志, 资源耗尽,阻塞小查询.

### Join Decomposition
分解join的好处:
-- select * from tag where tag = 'mysql';
-- select * from tag_post where  tag_id=1234;
-- select * from post where post.id in (123,456,567,9098,8904);
- 缓存更高效. 比如第一条可能已经缓存了.再比如缓存了9098,8904,可以只查前三.
- 单独查表,可以减少锁表的情况.
- 更容易分库分表
- in比连表更快.
- 减少获取的重复数据,减少网络和内存使用.

## Query Execution Basics
client -> server -> engine -> server -> client
1. client -> server(SQL statement)
2. server parses, preprocesses, and optimizes into query execution plan
3. query execution engine executes the plan by calling the storage engine API
4. the server sends the result to the client
 
### The MySQL Client/Server Protocol
通信协议是half-duplex,server要么发送,要么接受.因此无法把消息截断.
client/server发送/接受消息是单线程的.
client只能发一个包,因此设置max_allowed_packet很重要.
server则可能返回多个packet,但是一定会发送完,所以Limit很重要.
The client is "drinking from the fire hose".
大多数连接MySQL的库,要么只返回需要的数据,要么缓存下来.因为一旦请求了,MySQL会锁住行和相关资源,直到返回数据.

### Query States
每个MySQL connection都有状态. 
# 这里对应就是展示所有连接.
SHOW FULL PROCESSLIST
Command列对应状态:
who has the ball
- Sleep: 等待client查询
- Query: 执行查询/返回数据给client
- Locked: 等待表锁,锁行不会造成这个问题
- Analyzing and statistics: 核对engine统计数据,优化查询
- Copying to tmp table [on disk]: 
  执行查询和复制结果到临时表,可能是group by, filesort, union.如果on disk结尾,则把临时表写入磁盘.
- Sorting result: 排序结果集

### The Query Optimization Process
把query转换成执行计划,有几步: 转化,预处理和优化.在这个过程错误会在这里抛出来.

#### The parser and the preprocessor
MySQL parse把query分解成tokens,然后把token构建成parse tree.
Parser使用SQL语法去解析和校验查询,比如顺序,是否多引号等等.
Preprocessor再校验parse tree,比如名称和别名,确保没用ambiguous.
接着,preprocessor校验权限.

#### The query optimizer
query可以有不同执行方法,得出相同的结果,optimizer找出最好的选项.
-- 检查cost, value是随机数据页数.
show status like 'Last_query_cost';
随机数据页数取决于: 表或索引的行数,索引不同值的数量,行或键的长度,键的分布.
不一定都选择最佳计划的原因:
- 统计数据可能不对,因为MVCC的原因,行数不一定对.
- 预估不一定等于实际执行,因为有时候实际是顺序IO,有时候pages是在内存或磁盘中.
- MySQL的最佳策略不一定是我们的最佳策略,我们要快,它要损耗最小
- MySQL不考虑正在运行的query,会影响结果
- 有时候并不实际最优,只是按规则来的.比如优先用全文索引,实际上由普通索引.
- Mysql不考虑非自身的方法
- optimizer不总是预估所有执行计划
优化分静态和动态(类似java反射)优化
优化:
- Reordering joins: 优化join顺序
- Converting OUTER JOINs to INNER JOIN: 有时候外联因为where的条件等于inner join
- Applying algebraic equivalence rules: 
  (5=5 and a > 5)->(a>5), ((a < b and b = c) and a = 5) -> b>5 and b=c and a =5
- count(),min(),max() optimization: 
  min直接用索引的最小值,max直接用索引的最大值. explain会显示Extra: Select tables optimized away.
- Evaluating and reducing constant expressions: 尽可能把不变的常数表达式计算出来
  有时候甚至直接把join变成单表查询.
- Covering index
- Subquery optimization: 
- Early termination: 提前终止,比如LIMIT.比如不可能的情况1=0,film_id=-1
  distinct, not exist(), left join
- Equality propagation: 等于的传播
- In() list comparisons: in的列表比较
  会先把list排序,然后再二分查找.

#### Table and index statistics
statistics不在server上,在engine上.
optimizer必须从engine获取statistics,才能选择最佳执行计划: 比如表或行的页数,表或索引的选择性,行或key的长度,key的分布.

#### MySQL's join execution strategy
MySQL认为一切都是join,包括单表查询,子查询.
MySQL执行UNION: 当作一系列单查,然后再把结果放入临时表,再读出来.
以前用的是嵌套join,现在改用了hash join.

#### The execution plan
-- 如果show warnings,就可以看到重构的query
EXPLAIN EXTENDED [query]
join is not a balanced tree, is a left-deep tree.

#### The join optimizer
join优化: 当顺序无关结果时,MySQL会优化join顺序

#### Sort optimizations
sort优化: 避免sort或者sort更少的行
MySQL不用索引产生排序结果,就得自己排序,无论在磁盘还是内存排序都叫filesort.
如果值能放到buffer中,MySQL用quicksort.如果不能就会分批快排,最后mergeSort.
filesort算法:
1. Two passes(old): 读row指针,根据字段排序,最后再读row输出结果.因为第二读很多random IO,性能损耗大
2. Single pass(new): 读row需要的字段,然后排序,最后输出结果.只读一次.
连表排序: 如果只有一个表,先排序再join;如果多个表,先join再排序.

### The Query Execution Engine
每个table代表一个handler.

### Returning Results to the Client
server渐进地产生和返回结果.好处是client可以一行一行地接受处理.

## Limitations of the MySQL Query Optimizer

### UNION Limitations
union的外部限制条件,不会优化到内部

### Equality Propagation
=传播时,有可能把坏的条件传播给其他表.

### Parallel Execution
MySQL一个query是单行的.

### SELECT and UPDATE on the Same Table
一张表不可以既查询又更新

## Optimizing Specific Types of Queries
这些优化还得看MySQL版本

### Optimizing COUNT() Queries
count()最容易被误解

#### What COUNT() does
count()分两种: count(row)和count(value),count是count不为null的值.
count(*),不是count所有列,而是count行,不需要优化.
count行时,应该始终使用count(*)

#### Simple optimizations
如何查多个不同条件的count:
1. select sum(if(color = 'blue', 1, 0)) as blue, sum(if(color = 'red', 1, 0)) as red from items;
2. select count(color = 'blue' or null) as blue, count(color = 'red' or null) as red from items;

#### Using an approximation
如果只需要近似值,直接用explain就可以了.
如果只需要近似,有时候可以把distinct给移除掉.

#### More complex optimizations
除了covering index,没有太好的办法优化了.考虑加缓存吧.

### Optimizing JOIN Queries
优化join:
- 确保连表字段有索引. 连A和B再column c上,加索引在第二张表上就可以了.
- 确保group by或order by的字段都在一张表,尝试用索引
- 升级MySQL注意join的语法

### Optimizing GROUP BY with ROLLUP
移除掉with ROLLUP

### Optimizing LIMIT and OFFSET
分页基本涉及排序和连表,最好在排序字段增加索引,否则会filesort.
分页问题,limit 10000,20.会生成10020rows,然后扔掉10000rows. 要么限制页码,要么使用更高效的offset.
用covering index,而不是所有列.
limit是没问题的,有问题的是OFFSET,OFFSET代表server生成和抛掉的行.可以把上次查询的游标记录下来.

### Optimizing SQL_CALC_FOUND_ROWS
SQL_CALC_FOUND_ROWS: 会告诉你有多少行,实际并不准确,只会告诉你需要的行数. 
更好的设计是只有下一页. 假如需要显示20行,那么查询21行,如果第21行是null,说明没有下一页.
直接查1000行,如果少于1000行,显示具体的分页.否则就显示超过1000行.
还可以用explain预估多少行,连google都不知道具体函数.你可以使用count(*)[有索引的情况]而不是用SQL_CALC_FOUND_ROWS.

### Optimizing UNION
用UNION ALL而不是UNION, UNION会去除重复的行,损耗相当大

## Summary
优化策略,不干,少干,干快点
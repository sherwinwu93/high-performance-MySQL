# 8 Query Performance Optimization
MySQL如何执行查询,以及推理出query的效率.

query不好,再好的schema和indexes页没用.
query,index,schema优化三者紧密联系,时不时回头看前两章.
query的不好要先考虑的事情->Mysql如何执行query,如何改变执行计划->Mysql没用优化的query,探索query优化的模式.
帮助你深入理解MySQL执行查询,这样可以推理query的高效/低效.

## Why Are Queries Slow?
query由subtasks组成,想优化query,减少subtasks(发生更少次,更快).
查询序列图: client->Server. (where parsed, planned, executed)
network, CPU, operations(statistics, planning, locking, retrieve rows), I/O
一般是operations不需要,重复,太慢,优化就是优化掉它们.

## Slow Query Basics: Optimize Data Access
1. 是不是查了自己不需要的数据. 比如太多行,或者太多列
2. MySQL server是不是分析了不需要的列

### Are you asking the Database for Data you don't need?
- Fetching more rows than needed: 加limit,需要多少行就返回多少行
- Fetching all columns from a multitable join: 连表时,别用*返回所有表的字段
- Fetching all columns: 对*时刻保持警惕.但是有缓存时,确实可以用*.
- Fetching the same data repeatedly: 经常重复查同一数据,可以缓存下

### Is MySQL Examining Too Much Data?
query metrics: 全部都在慢查询日志里
- Response time
- Number of rows examined
- Number of rows returned
#### Response time
查询时间最好按第一次的来.
Response time: 分为service time(执行查询时间), queue time(等待IO, 等待锁) 这部分是性能最大的影响部分.
因此Response time 因为环境不同,queue time也不同,差异很大.
如何评估queue time? 预估需要的顺序IO和随机IO * 需要硬件的时间,对比实际的时间.

#### Rows examined and rows returned
需要检视的行数很有用.少的行数要快,但是存储在内存比硬盘中的要快.
理想情况下,检视的行和返回的行数相同.实际上连表时,返回的行数比检视的行数少很多.

#### Rows examined and access types
查询单行,有时候会examine很多行,有时候不用examine行.
scanning a table, scanning an index, range accesses, and single-value accesses
如果访问类型差,那么可能需要加索引.索引之所以重要,是因为可以让MySQLexamine更少的行.


## Ways to Restructure Queries

## Query Execution Basics

## Limitations of the MySQL Query Optimizer

## Optimizing Specific Types of Queries

## Summary
stop doing things, do them fewer times, do them more quickly
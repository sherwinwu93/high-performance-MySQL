# 8 Query Performance Optimization
MySQL如何执行查询,以及推理出query的效率.

query不好,再好的schema和indexes也性能差.
query,index,schema优化三者紧密联系,时不时回头看前两章.
1. query性能不好时有限考虑的事物.
2. query优化和server内部.
3. 如何执行query和改变query
4. Mysql没优化好的地方,一些query优化的模式.
帮助你深入理解MySQL执行查询,这样可以推理query的高效/低效.

wusd:
1. query性能不好时需要优先考虑的事物.
2. query优化和server内部.
3. 如何执行query和改变query
4. Mysql没优化好的地方,一些query优化的模式.

## Why Are Queries Slow? :因为subtasks慢或多
query由subtasks组成,想优化query,就要减少subtasks(发生更少次,更快).
脑补查询流程图: parsed, planned, executed, back to client.(execution: client-> server)
network, CPU, operations(statistics, planning, locking, retrieve rows), I/O
一般是operations不需要,重复,太慢,优化就是优化掉它们.

:wusd
query的subtasks
1. parse
2. plan
3. execute(client -> server)
4. back to client
------
subtasks花费时间:
1. network
2. CPU
3. operations(statistics, planning, locking, retrieve rows)
4. I/O
------
优化就是让subtask更少,更快.

## Slow Query Basics: Optimize Data Access
1. 是不是查了自己不需要的数据. 比如太多行,或者太多列
2. MySQL server是不是分析了不需要的行

:wusd
优化数据访问
1. 自身是否查了不需要的行,列
2. MySQL server是否分析了不需要的行

### Are you asking the Database for Data you don't need?
- Fetching more rows than needed: 加limit,需要多少行就返回多少行
- Fetching all columns from a multitable join: 连表时,别用*返回所有表的字段
- Fetching all columns: 对*时刻保持警惕.但是有缓存时,确实可以用*.
- Fetching the same data repeatedly: 经常重复查同一数据,可以缓存下

:wusd
查自己不需要的行或列
1. 查超过自己需要的行: 比如只需要10行,实际全部查出来了
  s:加limit限制
2. 连表时,把所有字段返回了:
   比如: select * from t1 inner join t2 on t1.id=t2.id
        s:可以优化成 select t2.* from t1 inner join t2 on t1.id=t2.id;
3. 返回所有字段: 对使用*保持警惕,但是做缓存时,可以用*.
4. 重复查同一数据: 
   s:缓存下

### Is MySQL Examining Too Much Data?
query metrics: 全部都在慢查询日志里
- Response time
- Number of rows examined
- Number of rows returned

:wusd
查询指标: 慢查询日志可看
- 响应时间
- 检查的行数
- 返回的行数

#### Response time
查询时间最好按第一次的来.
Response time: 分为service time(执行查询时间), queue time(等待IO, 等待锁) 这部分是性能最大的影响部分.
因此Response time 因为环境不同,queue time也不同,差异很大.
如何评估queue time? 预估需要的顺序IO和随机IO * 需要硬件的时间,对比实际的时间.

:wusd
Response Time响应时间:
1. Service time: 实际执行查询时间
2. Queue time: 排队时间,等待IO/锁
---------
评估响应时间:
1. 检验查询执行计划,涉及的索引,
2. 推导出涉及的序列IO和随机IO次数
3. 用次数*耗时,评估响应时间

#### Rows examined and rows returned
需要检视的行数很有用.少的行数要快,但是存储在内存比硬盘中的要快.
理想情况下,检视的行和返回的行数相同.实际上连表时,返回的行数比检视的行数少很多.

:wusd
1. 检视的行数是query的重要性能指标.但是不一定准,因为从行在内存比硬盘快.
2. 检视行数很难等于返回行数,比如在连表时(10:1)

#### Rows examined and access types
查询单行,有时候会examine很多行,有时候不用examine行.access methods???
scanning a table, scanning an index, range accesses, and single-value accesses
如果访问类型差,那么可能需要加索引.索引之所以重要,是因为可以让MySQLexamine更少的行.
MySQL应用Where的三种情况:
1. 用索引去掉不匹配的行,在引擎层
2. 用覆盖索引避免访问行,在获取索引的全部数据后,过滤掉不匹配的行,在Server层.Extra Using index
3. 从行中获取所有数据,然后过滤.Extra Using where
-----
如果你发现examine要远大于return
- 使用覆盖索引,storage engine不必返回所有行
- 改变schema, 使用Summary tables(第六章)
- 重写复杂查询

:wusd
行检索和访问类型: 好的索引帮忙获得更好的访问类型,检索更少的行
1. access method在explain的type字段
    1. scanning a table
    2. scanning an index
    3. range accesses
    4. single-value accesses
2. 如果访问类型差,最好的方法通常是加相应的索引
```sql
-- 有索引时
create index idx_fk_film_id on film_actor(film_id);
explain select * from film_actor where film_id = 1;
-- return: type: ref, rows: 10
-- 没索引时
ALTER TABLE sakila.film_actor DROP KEY idx_fk_film_id;
EXPLAIN SELECT * FROM sakila.film_actor WHERE film_id = 1;
-- return: type: ALL, rows: 5462, Extra: Using where
-- type: ALL 全表扫描, 需要扫描5462行, Using where表示引擎在查到后使用where过滤行.
```
Where使用情况: 由好到坏
1. 在引擎层,用索引去掉不匹配的行
2. 在server层,使用覆盖索引过滤掉不匹配的行,(不读表读索引).Extra: Using index
3. 在Server层,使用where过滤行.Extra: Using where
------
MySQL只告诉需要检视的行数,不告诉用于构建结果返回的行数
```sql
-- 构建结果需要的行数是200,但是需要检视的行是5642
select actor_id, count(*) from film_actor group by actor_id;
EXPLAIN SELECT actor_id, count(*) FROM film_actor GROUP BY actor_id;
```
发现返回行数远小于检视行数:
1. 使用覆盖索引,这样不用查行
2. 改变schema,使用summary表
3. 重写复杂查询

## Ways to Restructure Queries
优化SQL时,找替代的方法获得你想要的结果,但是从MySQL的结果集不一定非要一样.

:wusd
优化SQL:
1. 重写SQL,SQL获取相同的结果和更好的性能
2. 重写SQL或者改变程序代码,获取不同的结果

### Complex Queries Versus Many Queries
之前认为复合查询比多个查询好,因为网络交流和查询转化和优化阶段的消耗.
现在MySQL QPS高,而且网络也比以前好,多个查询不是什么坏事.
MySQL内部还是比网络快,但是如果分解查询能比复合查询好,就分解.

:wusd
复合查询vs多次查询:
1. 之前认为复合查询比多个查询好,因为网络和查询转化和优化阶段的消耗.
2. 现在MySQL QPS高,网络也比以前好,多次查询不必复合查询查.
3. 多次查询如果比复合查询好,就分解;但是也别能一次查10行,非要10次查一行.

### Chopping Up a Query
批量删除时,每次delete10000行.
因为一次性清除大量数据,会长时间锁很多行,塞满事务日志, 资源耗尽,阻塞小查询.

:wusd
大规模批量处理数据应该分批处理.因为大规模处理,会长时间锁行,堵塞事物日志,导致资源耗尽,阻塞不该阻塞的小查询.
eg. 大规模删除->分批删除小部分数据
```sql
delete from messages
where created < DATE_SUB(now(), interval 3 month);
-- 优化后
rows_affected = 0
do {
    rows_affected = do_query(
    "DELETE FROM messages where created < DATE_SUB(now(), interval 3 month) 
    LIMIT 10000"
    )
} while rows_affected > 0
```

### Join Decomposition
分解join的好处:
-- select * from tag where tag = 'mysql';
-- select * from tag_post where  tag_id=1234;
-- select * from post where post.id in (123,456,567,9098,8904);
- 缓存更高效. 比如第一条可能已经缓存了.再比如缓存了9098,8904,可以只查前三.
- 单独查表,可以减少锁表的情况.
- 更容易分库分表
- in比连表更快.
- 减少获取的重复数据,减少网络和内存使用.

:wusd
把连表分解成多个查询:
```sql
select * from tag
join tag_post on tag_post.tag_id = tag.id
join post on tag_post.post_id = post.id
where tag.tag = 'mysql';
-- 优化后
select * from tag where tag = 'mysql';
select * from tag_post where tag_id = 1234;
select * from post where post.id in (123,456,567,9098,8904);
```
1. 缓存更加高效了.比如缓存了9098,8904,可以只查前三个.
2. 查单表减少锁行.
3. 更易水平伸缩.
4. in()比连表更快
5. 减少重复数据获取,减少网络和内存使用.

## Query Execution Basics
client -> server -> engine -> server -> client
1. client -> server(SQL statement)
2. server parses, preprocesses, and optimizes into query execution plan
3. query execution engine executes the plan by calling the storage engine API
4. the server sends the result to the client

:wusd
query执行步骤: query optimizer异常复杂和重要
1. client发生SQL到server
2. Parser转换SQL为Parse tree
3. Preprocessor对Parse tree进行优化
4. Query Optimizer把parse tree优化成query execution plan!!!
5. Query execution engine调用storage engine API执行plan
6. sever返回结果给client
 
### The MySQL Client/Server Protocol
通信协议是half-duplex,server要么发送,要么接受.因此无法把消息截断.
client/server发送/接受消息是单线程的.
client只能发一个包,因此设置max_allowed_packet很重要.
server则可能返回多个packet,但是一定会发送完,所以Limit很重要.
The client is "drinking from the fire hose".
大多数连接MySQL的库,要么只返回需要的数据,要么缓存下来.因为一旦请求了,MySQL会锁住行和相关资源,直到返回数据.

:wusd
MySQL client/server协议:
1. 通信协议是half-duplex,sever要么发送,要么接收.
2. client一次只能发送一个包,因此max_allowed_packet配置很重要,查询太大会报错
3. server可以返回多个packet,一定会全部发送完

### Query States
每个MySQL connection都有状态. 
这里对应就是展示所有连接.
SHOW FULL PROCESSLIST
Command列对应状态:
who has the ball
- Sleep: 等待client查询
- Query: 执行查询/返回数据给client
- Locked: 等待表锁,锁行不会造成这个问题
- Analyzing and statistics: 核对engine统计数据,优化查询
- Copying to tmp table [on disk]: 
  执行查询和复制结果到临时表,可能是group by, filesort, union.如果on disk结尾,则把临时表写入磁盘.
- Sorting result: 排序结果集

:wusd
Query State: MySQL连接(Thread)的状态, who has the ball?
- Sleep: 等待client查询
- Query: 执行查询/返回数据给client
- Locked: 等待表锁,锁行不会造成这个问题
- Analyzing and statistics: 核对engine统计数据,优化查询
- Copying to tmp table [on disk]:
  执行查询和复制结果到临时表,可能是group by, filesort, union.如果on disk结尾,则把临时表写入磁盘. 
- Sorting result: 排序结果集
```sql
-- 查询所有连接
show full processlist;
```

### The Query Optimization Process
把query转换成执行计划,有几步: 转化,预处理和优化.在这个过程错误会在这里抛出来.

:wusd
query转化成执行计划,有几步: 转换,预处理和优化.错误会在这个过程抛出来.

#### The parser and the preprocessor
MySQL parse把query分解成tokens,然后把token构建成parse tree.
Parser使用SQL语法去解析和校验查询,比如顺序,是否多引号等等.
Preprocessor再校验parse tree,比如名称和别名,确保没用ambiguous.
接着,preprocessor校验权限.

:wusd
parser和preprocessor:
parser:
1. 分解query成tokens,构建parse tree
2. 校验查询是否合法,比如顺序,引号等等
------
preprocessor:
1. 校验parse tree, 表和字段是否存在.名称和别名,确保不是ambiguous
2. 校验权限

#### The query optimizer
query可以有不同执行方法,得出相同的结果,optimizer找出最好的选项.
-- 检查cost, value是随机数据页数.
```sql
select SQL_NO_CACHE count(*) from film_actor;
show status like 'Last_query_cost';
```
随机数据页数取决于: 表或索引的行数,索引不同值的数量,行或键的长度,键的分布.
不一定都选择最佳计划的原因:
- 统计数据可能不对,因为MVCC的原因,行数不一定对.
- 预估不一定等于实际执行,因为有时候实际是顺序IO,有时候pages是在内存或磁盘中.
- MySQL的最佳策略不一定是我们的最佳策略,我们要快,它要损耗最小
- MySQL不考虑正在运行的query,会影响结果
- 有时候并不实际最优,只是按规则来的.比如优先用全文索引,实际上由普通索引.
- Mysql不考虑非自身的方法的损耗,比如自定义的方法
- optimizer不总是预估所有执行计划
优化分静态和动态(类似java反射)优化
优化:
- Reordering joins: 优化join顺序
- Converting OUTER JOINs to INNER JOIN: 有时候外联因为where的条件等于inner join
- Applying algebraic equivalence rules: 
  (5=5 and a > 5)->(a>5), ((a < b and b = c) and a = 5) -> b>5 and b=c and a =5
- count(),min(),max() optimization: 
  min直接用索引的最小值,max直接用索引的最大值. explain会显示Extra: Select tables optimized away.
- Evaluating and reducing constant expressions: 尽可能把不变的常数表达式计算出来
  有时候甚至直接把join变成单表查询.
- Covering index
- Subquery optimization: 
- Early termination: 提前终止,比如LIMIT.比如不可能的情况1=0,film_id=-1
  distinct, not exist(), left join
- Equality propagation: 等于的传播
- In() list comparisons: in的列表比较
  会先把list排序,然后再二分查找.

:wusd
optimizer是cost-based的,预测执行计划的cost,然后选择cost最小的.
```sql
-- select SQL_NO_CACHE count(*) from film_actor;
-- 查询cost
show status like 'last_query_cost';
```
cost基于需要read的随机页数.随机页数取决于表或索引的行数,索引不同值的数量,行或键的长度,键的分布.
optimizer不一定选择最佳的plan:
1. 预估使用的统计数据可能不对,比如因为MVCC的原因,行数不一定对.
2. 预估指标不等于实际执行,有时候顺序IO,或者在内存中要快很多.
3. MySQL的最优不是你最优策略,MySQL要cost少,你需要时间快
4. MySQL不考虑其他同时运行的query,会影响结果
5. MySQL不总是做cost-based优化,有时候机械执行规则.比如有时候普通索引比全文索引更优.
6. MySQL不考虑非自身方法的额外开销,比如用户自定义的方法
7. MySQL无法预估所有执行计划,所以miss了优化计划.
静态优化检查parse tree,动态优化则在每次查询后运行.
-------
MySQL优化:
1. Reordering joins: 优化join顺序
2. 转化outer joins to inner join: 有时候外联因为where条件等于inner join
3. Applying algebraic equivalence rules: 优化一些算法表达式
   (5=5 and a > 5)->(a>5), ((a < b and b = c) and a = 5) -> b>5 and b=c and a =5
4. count(),min(),max() optimization: 直接用索引,不查表
   min直接用索引的最小值,max直接用索引的最大值. explain会显示Extra: Select tables optimized away.
5. Evaluating and reducing constant expressions: 计算和减少常量表达式,在连表会常量传播
```sql
explain select film.film_id, film_actor.actor_id from film
inner join film_actor using(film_id)
where film.film_id = 1;
-- film和film_actor的ref都是const
```
6. Covering index: 覆盖索引
7. Subquery optimization: 把一些子查询转换成索引查询
8. Early termination: 提前终止,比如LIMIT.比如不可能的情况1=0,film_id=-1.
    is null, distinct, not exist(), left join,(只要存在一个就满足该条件,会提前停止)
```sql
-- 只要film_actor.actor_id存在一个就会停止找下去
explain select film_id from film where film_id = -1;
select film_id from film
left join film_actor using(film_id)
where film_actor.actor_id is null;
```
9. Equality propagation: 等于的传播
```sql
select film_id from film
inner join film_actor using(film_id)
where film.film_id > 500;
-- 等价于
select film_id from film
inner join film_actor using(film_id)
where film.film_id > 500 and film_actor.film_id > 500;
```
10. in() list comparisons: in的列表比较,先做排序,再二分查找

#### Table and index statistics
statistics不在server上,在engine上.
optimizer必须从engine获取statistics,才能选择最佳执行计划: 比如表或行的页数,表或索引的选择性,行或key的长度,key的分布.

:wusd
statistics不在server在engine上,所以optimizer必须从engine获取statistics,才能选择最佳执行计划.

#### MySQL's join execution strategy
MySQL认为一切都是join,包括单表查询,子查询.
MySQL执行UNION: 当作一系列单查,然后再把结果放入临时表,再读出来.
以前用的是嵌套join,现在改用了hash join.

:wusd
MySQL认为一切都是join,包括单表查询,子查询.
MySQL执行UNION: 当作一系列单查,然后再把结果放入临时表,再读出来.
以前版本用的是嵌套join,现在用hash join(放在内存中).

#### The execution plan
-- 如果show warnings,就可以看到重构的query
EXPLAIN EXTENDED [query]
join is not a balanced tree, is a left-deep tree.

:wusd
执行计划: MySQL join使用的是左深树.
```sql
-- 显示执行计划
explain analyze
select film_id from film
left join film_actor using(film_id)
where film_actor.actor_id is null;
```

#### The join optimizer
join优化: 当顺序无关结果时,MySQL会优化join顺序

:wusd
join优化: 当顺序无关结果时,MySQL会优化join顺序
n个表连接,就有n!种执行计划,所以optimizer_search_depth会限制深度,因此不一定能找到最优的计划.
left join时,不会做优化,因为其他表的结果依赖上一个表.(left join在写SQL除非必要,尽量不用)
```sql
explain 
select film.film_id, film.title, film.release_year,
       actor.actor_id, actor.first_name, actor.last_name from film
inner join film_actor using(film_id)
inner join actor using(actor_id);
explain
select straight_join film.film_id, film.title, film.release_year,
       actor.actor_id, actor.first_name, actor.last_name from film
inner join film_actor using(film_id)
inner join actor using(actor_id);
```

#### Sort optimizations
sort优化: 避免sort或者sort更少的行
MySQL不用索引产生排序结果,就得自己排序,无论在磁盘还是内存排序都叫filesort.
如果值能放到buffer中,MySQL用quicksort.如果不能就会分批快排,最后mergeSort.
filesort算法:
1. Two passes(old): 读row指针和排序字段,根据字段排序,最后再读row输出结果.因为第二读很多random IO,性能损耗大
2. Single pass(new): 读row需要的字段,然后排序,最后输出结果.只读一次.
连表排序: 如果只有一个表,先排序再join;如果多个表,先join再排序.

### The Query Execution Engine
每个table代表一个handler.

### Returning Results to the Client
server渐进地产生和返回结果.好处是client可以一行一行地接受处理.

## Limitations of the MySQL Query Optimizer

### UNION Limitations
union的外部限制条件,不会优化到内部

### Equality Propagation
=传播时,有可能把坏的条件传播给其他表.

### Parallel Execution
MySQL一个query是单行的.

### SELECT and UPDATE on the Same Table
一张表不可以既查询又更新

## Optimizing Specific Types of Queries
这些优化还得看MySQL版本

### Optimizing COUNT() Queries
count()最容易被误解

#### What COUNT() does
count()分两种: count(row)和count(value),count是count不为null的值.
count(*),不是count所有列,而是count行,不需要优化.
count行时,应该始终使用count(*)

#### Simple optimizations
如何查多个不同条件的count:
1. select sum(if(color = 'blue', 1, 0)) as blue, sum(if(color = 'red', 1, 0)) as red from items;
2. select count(color = 'blue' or null) as blue, count(color = 'red' or null) as red from items;

#### Using an approximation
如果只需要近似值,直接用explain就可以了.
如果只需要近似,有时候可以把distinct给移除掉.

#### More complex optimizations
除了covering index,没有太好的办法优化了.考虑加缓存吧.

### Optimizing JOIN Queries
优化join:
- 确保连表字段有索引. 连A和B再column c上,加索引在第二张表上就可以了.
- 确保group by或order by的字段都在一张表,尝试用索引
- 升级MySQL注意join的语法

### Optimizing GROUP BY with ROLLUP
移除掉with ROLLUP

### Optimizing LIMIT and OFFSET
分页基本涉及排序和连表,最好在排序字段增加索引,否则会filesort.
分页问题,limit 10000,20.会生成10020rows,然后扔掉10000rows. 要么限制页码,要么使用更高效的offset.
用covering index,而不是所有列.
limit是没问题的,有问题的是OFFSET,OFFSET代表server生成和抛掉的行.可以把上次查询的游标记录下来.

### Optimizing SQL_CALC_FOUND_ROWS
SQL_CALC_FOUND_ROWS: 会告诉你有多少行,实际并不准确,只会告诉你需要的行数. 
更好的设计是只有下一页. 假如需要显示20行,那么查询21行,如果第21行是null,说明没有下一页.
直接查1000行,如果少于1000行,显示具体的分页.否则就显示超过1000行.
还可以用explain预估多少行,连google都不知道具体函数.你可以使用count(*)[有索引的情况]而不是用SQL_CALC_FOUND_ROWS.

### Optimizing UNION
用UNION ALL而不是UNION, UNION会去除重复的行,损耗相当大

## Summary
优化策略,不干,少干,干快点
# 8 Query Performance Optimization
MySQL如何执行查询,以及推理出query的效率.

query不好,再好的schema和indexes页没用.
query,index,schema优化三者紧密联系,时不时回头看前两章.
query的不好要先考虑的事情->Mysql如何执行query,如何改变执行计划->Mysql没用优化的query,探索query优化的模式.
帮助你深入理解MySQL执行查询,这样可以推理query的高效/低效.

## Why Are Queries Slow?
query由subtasks组成,想优化query,减少subtasks(发生更少次,更快).
查询序列图: client->Server. (where parsed, planned, executed)
network, CPU, operations(statistics, planning, locking, retrieve rows), I/O
一般是operations不需要,重复,太慢,优化就是优化掉它们.

## Slow Query Basics: Optimize Data Access
1. 是不是查了自己不需要的数据. 比如太多行,或者太多列
2. MySQL server是不是分析了不需要的列

### Are you asking the Database for Data you don't need?
- Fetching more rows than needed: 加limit,需要多少行就返回多少行
- Fetching all columns from a multitable join: 连表时,别用*返回所有表的字段
- Fetching all columns: 对*时刻保持警惕.但是有缓存时,确实可以用*.
- Fetching the same data repeatedly: 经常重复查同一数据,可以缓存下

### Is MySQL Examining Too Much Data?
query metrics: 全部都在慢查询日志里
- Response time
- Number of rows examined
- Number of rows returned
#### Response time
查询时间最好按第一次的来.
Response time: 分为service time(执行查询时间), queue time(等待IO, 等待锁) 这部分是性能最大的影响部分.
因此Response time 因为环境不同,queue time也不同,差异很大.
如何评估queue time? 预估需要的顺序IO和随机IO * 需要硬件的时间,对比实际的时间.

#### Rows examined and rows returned
需要检视的行数很有用.少的行数要快,但是存储在内存比硬盘中的要快.
理想情况下,检视的行和返回的行数相同.实际上连表时,返回的行数比检视的行数少很多.

#### Rows examined and access types
查询单行,有时候会examine很多行,有时候不用examine行.
scanning a table, scanning an index, range accesses, and single-value accesses
如果访问类型差,那么可能需要加索引.索引之所以重要,是因为可以让MySQLexamine更少的行.
MySQL应用Where的三种情况:
1. 用索引去掉不匹配的行,在引擎层
2. 用覆盖索引避免访问行,在获取索引的全部数据后,过滤掉不匹配的行,在Server层.Extra Using index
3. 从行中获取所有数据,然后过滤.Extra Using where
-----
如果你发现examine要远大于return
- 使用覆盖索引,storage engine不必返回所有行
- 改变schema, 使用Summary tables(第六章)
- 重写复杂查询


## Ways to Restructure Queries
优化SQL时,找替代的方法获得你想要的结果,但是从MySQL的结果集不一定非要一样.

### Complex Queries Versus Many Queries
之前认为复合查询比多个查询好,因为网络交流和查询转化和优化阶段的消耗.
现在MySQL QPS高,而且网络也比以前好,多个查询不是什么坏事.
MySQL内部还是比网络快,但是如果分解查询能比复合查询好,就分解.

### Chopping Up a Query
批量删除时,每次delete10000行.
因为一次性清除大量数据,会长时间锁很多行,塞满事务日志, 资源耗尽,阻塞小查询.

### Join Decomposition
分解join的好处:
-- select * from tag where tag = 'mysql';
-- select * from tag_post where  tag_id=1234;
-- select * from post where post.id in (123,456,567,9098,8904);
- 缓存更高效. 比如第一条可能已经缓存了.再比如缓存了9098,8904,可以只查前三.
- 单独查表,可以减少锁表的情况.
- 更容易分库分表
- in比连表更快.
- 减少获取的重复数据,减少网络和内存使用.

## Query Execution Basics
client -> server -> engine -> server -> client
1. client -> server(SQL statement)
2. server parses, preprocesses, and optimizes into query execution plan
3. query execution engine executes the plan by calling the storage engine API
4. the server sends the result to the client
 
### The MySQL Client/Server Protocol
通信协议是half-duplex,server要么发送,要么接受.因此无法把消息截断.
client/server发送/接受消息是单线程的.
client只能发一个包,因此设置max_allowed_packet很重要.
server则可能返回多个packet,但是一定会发送完,所以Limit很重要.
The client is "drinking from the fire hose".
大多数连接MySQL的库,要么只返回需要的数据,要么缓存下来.因为一旦请求了,MySQL会锁住行和相关资源,直到返回数据.

### Query States
每个MySQL connection都有状态. 
# 这里对应就是展示所有连接.
SHOW FULL PROCESSLIST
Command列对应状态:
who has the ball
- Sleep: 等待client查询
- Query: 执行查询/返回数据给client
- Locked: 等待表锁,锁行不会造成这个问题
- Analyzing and statistics: 核对engine统计数据,优化查询
- Copying to tmp table [on disk]: 
  执行查询和复制结果到临时表,可能是group by, filesort, union.如果on disk结尾,则把临时表写入磁盘.
- Sorting result: 排序结果集

### The Query Optimization Process
把query转换成执行计划,有几步: 转化,预处理和优化.在这个过程错误会在这里抛出来.

#### The parser and the preprocessor
MySQL parse把query分解成tokens,然后把token构建成parse tree.
Parser使用SQL语法去解析和校验查询,比如顺序,是否多引号等等.
Preprocessor再校验parse tree,比如名称和别名,确保没用ambiguous.
接着,preprocessor校验权限.

#### The query optimizer
query可以有不同执行方法,得出相同的结果,optimizer找出最好的选项.
-- 检查cost, value是随机数据页数.
show status like 'Last_query_cost';
随机数据页数取决于: 表或索引的行数,索引不同值的数量,行或键的长度,键的分布.
不一定都选择最佳计划的原因:
- 统计数据可能不对,因为MVCC的原因,行数不一定对.
- 预估不一定等于实际执行,因为有时候实际是顺序IO,有时候pages是在内存或磁盘中.
- MySQL的最佳策略不一定是我们的最佳策略,我们要快,它要损耗最小
- MySQL不考虑正在运行的query,会影响结果
- 有时候并不实际最优,只是按规则来的.比如优先用全文索引,实际上由普通索引.
- Mysql不考虑非自身的方法
- optimizer不总是预估所有执行计划
优化分静态和动态(类似java反射)优化
优化:
- Reordering joins: 优化join顺序
- Converting OUTER JOINs to INNER JOIN: 有时候外联因为where的条件等于inner join
- Applying algebraic equivalence rules: 
  (5=5 and a > 5)->(a>5), ((a < b and b = c) and a = 5) -> b>5 and b=c and a =5
- count(),min(),max() optimization: 
  min直接用索引的最小值,max直接用索引的最大值. explain会显示Extra: Select tables optimized away.
- Evaluating and reducing constant expressions: 尽可能把不变的常数表达式计算出来
  有时候甚至直接把join变成单表查询.
- Covering index
- Subquery optimization: 
- Early termination: 提前终止,比如LIMIT.比如不可能的情况1=0,film_id=-1
  distinct, not exist(), left join
- Equality propagation: 等于的传播
- In() list comparisons: in的列表比较
  会先把list排序,然后再二分查找.

#### Table and index statistics

#### MySQL's join execution strategy

#### The execution plan

#### The join optimizer

#### Sort optimizations

### The Query Execution Engine

### Returning Results to the Client

## Limitations of the MySQL Query Optimizer

## Optimizing Specific Types of Queries

## Summary
stop doing things, do them fewer times, do them more quickly
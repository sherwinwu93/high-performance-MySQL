# 8 Query Performance Optimization
MySQL如何执行查询,以及推理出query的效率.

query不好,再好的schema和indexes也性能差.
query,index,schema优化三者紧密联系,时不时回头看前两章.
1. query性能不好时有限考虑的事物.
2. query优化和server内部.
3. 如何执行query和改变query
4. Mysql没优化好的地方,一些query优化的模式.
帮助你深入理解MySQL执行查询,这样可以推理query的高效/低效.

:wusd
查询性能优化:
1. query性能不好时,第一需要考虑的事情
2. MySQL如何执行query和改变query执行计划
3. MySQL没优化好的地方,以及一些优化的模式

## Why Are Queries Slow? :因为subtasks慢或多
query由subtasks组成,想优化query,就要减少subtasks(发生更少次,更快).
脑补查询流程图: parsed, planned, executed, back to client.(execution: client-> server)
network, CPU, operations(statistics, planning, locking, retrieve rows), I/O
一般是operations不需要,重复,太慢,优化就是优化掉它们.

:wusd
为什么查询慢?
查询由subtasks组成,subtasks多,重复,慢,导致最终查询慢?
脑部查询生命周期:
1. parse
2. plan
3. execution:(最重要,从引擎获取行,分组~排序)
4. back to client
-----
subtasks花费时间: 网络~CPU~IO
- statistics统计
- planning规划
- locking锁
- retrieve rows获取行

## Slow Query Basics: Optimize Data Access
1. 是不是查了自己不需要的数据. 比如太多行,或者太多列
2. MySQL server是不是分析了不需要的行

:wusd
慢查询基础: 优化数据访问
1. 查了很多不需要的行或列
2. MySQL server分析了不需要的行

### Are you asking the Database for Data you don't need?
- Fetching more rows than needed: 加limit,需要多少行就返回多少行
- Fetching all columns from a multitable join: 连表时,别用*返回所有表的字段
- Fetching all columns: 对*时刻保持警惕.但是有缓存时,确实可以用*.
- Fetching the same data repeatedly: 经常重复查同一数据,可以缓存下

:wusd
查自己不需要的行或列
1. 查超过自己需要的行: 比如只需要10行,实际全部查出来了
  s:加limit限制
2. 连表时,把所有字段返回了:
   比如: select * from t1 inner join t2 on t1.id=t2.id
        s:可以优化成 select t2.* from t1 inner join t2 on t1.id=t2.id;
3. 返回所有字段: 对使用*保持警惕,但是做缓存时,可以用*.
4. 重复查同一数据: 
   s:缓存下

:wusd
是否向数据库查自己不需要的数据?
典型错误:
- 查太多行: eg: 用10行,查100行.
  所以limit很重要
- 连表时返回了所有字段
```sql
select * from actor
inner join film_actor using(actor_id)
inner join film using(film_id)
where film.title = 'Academy Dinosaur';
-- 
select actor.* from actor
                  inner join film_actor using(actor_id)
                  inner join film using(film_id)
where film.title = 'Academy Dinosaur';
```
- 查所有字段(select *): 尽量不用*,只有缓存时用*
- 重复获取相同数据: 缓存下

### Is MySQL Examining Too Much Data?
query metrics: 全部都在慢查询日志里
- Response time
- Number of rows examined
- Number of rows returned

:wusd
MySQL检查了太多数据?
查询指标: 慢SQL日志可查
- 响应时间
- 检查的行数
- 返回的行数

#### Response time
查询时间最好按第一次的来.
Response time: 分为service time(执行查询时间), queue time(等待IO, 等待锁) 这部分是性能最大的影响部分.
因此Response time 因为环境不同,queue time也不同,差异很大.
如何评估queue time? 预估需要的顺序IO和随机IO * 需要硬件的时间,对比实际的时间.

:wusd
响应时间:
1. service time: 实际执行查询时间
2. queue time: 排队时间,等待IO/锁
------
评估响应时间:
1. 检查查询执行计划,涉及的索引
2. 涉及的序列IO和随机IO次数
3. 用次数*耗时,评估响应时间

#### Rows examined and rows returned
需要检视的行数很有用.少的行数要快,但是存储在内存比硬盘中的要快.
理想情况下,检视的行和返回的行数相同.实际上连表时,返回的行数比检视的行数少很多.

:wusd
检查的行和返回的行:
1. 检查的行数非常重要,但不一定准,比如:短行比长行,存储在内存的行比硬盘快.
2. 检查的行很难等于返回行数,比如:连表时一般要10:1

#### Rows examined and access types
查询单行,有时候会examine很多行,有时候不用examine行.access methods???
scanning a table, scanning an index, range accesses, and single-value accesses
如果访问类型差,那么可能需要加索引.索引之所以重要,是因为可以让MySQLexamine更少的行.
MySQL应用Where的三种情况:
1. 用索引去掉不匹配的行,在引擎层
2. 用覆盖索引避免访问行,在获取索引的全部数据后,过滤掉不匹配的行,在Server层.Extra Using index
3. 从行中获取所有数据,然后过滤.Extra Using where
-----
如果你发现examine要远大于return
- 使用覆盖索引,storage engine不必返回所有行
- 改变schema, 使用Summary tables(第六章)
- 重写复杂查询

:wusd
检查行和访问类型: 
1. 访问类型不同检查的行数不同,有些访问类型不用检查行
2. 访问类型: explain [SQL]的type字段
    1. ALL: 全表扫描
    2. index: 全索引扫描
    3. range: 范围扫描
    4. ref/eq_ref(连表): 非唯一索引扫描
    5. const: 唯一/主键索引扫描
3. 如果访问类型差,最好的方法通常是加相应的索引
```sql
ALTER table film_actor add key idx_fk_film_id(film_id);
-- 返回10行
select * from film_actor where film_id = 1;
-- 有访问类型是ref,检查10行
explain select * from film_actor where film_id = 1;
-- 如果没有索引,访问类型是ALL,检查5462行
alter table film_actor drop foreign key fk_film_actor_film;
ALTER table film_actor drop key idx_fk_film_id;
explain select * from film_actor where film_id = 1;
```
4. where的使用方式,从好到坏:
   1. 使用索引去除不匹配的行,在引擎层
   2. 使用covering index避免回表,在server层
   3. Using where,回表过滤,在server层
5. 有时有索引也优化不了
```sql
-- 返回200行
select actor_id, count(*) from film_actor group by actor_id;
-- 检查5462行,加索引也减少不了检查行数,因为没有where筛选
explain select actor_id, count(*) from film_actor group by actor_id;
```
6. 如果返回行数远小于检查行数:
   1. 使用covering index,不用回表
   2. 改变schema,使用summary tables
   3. 重写复杂查询

## Ways to Restructure Queries
优化SQL时,找替代的方法获得你想要的结果,但是从MySQL的结果集不一定非要一样.

:wusd
重构SQL的方法:
1. 两大思路:
   1. MySQL的结果集一样,优化性能
   2. MySQL结果集不一样,程序结果一样,优化性能
2. 重构具体方法:
   1. 复合查询变多个子查询
   2. 切割查询: 把查询切分成多个小查询
   3. 分解连表

### Complex Queries Versus Many Queries
之前认为复合查询比多个查询好,因为网络交流和查询转化和优化阶段的消耗.
现在MySQL QPS高,而且网络也比以前好,多个查询不是什么坏事.
MySQL内部还是比网络快,但是如果分解查询能比复合查询好,就分解.

:wusd
复合查询vs多次查询:
1. 传统认为复合查询比多个查询好,因为网络和parse~optimize的原因.
2. 现在MySQL QPS高,网络比之前好,第1点无效
3. 因此,多次查询比复合查询好,可以分解;但是也别能一次查10行,非要10次查一行.

### Chopping Up a Query
批量删除时,每次delete10000行.
因为一次性清除大量数据,会长时间锁很多行,塞满事务日志, 资源耗尽,阻塞小查询.

:wusd
切割查询: 把大规模批量处理数据,改成分批处理.因为会长时间锁行,堵塞事务日志,耗尽资源,导致堵塞小查询.
eg. 大规模删除->分批删除小部分数据; 大规模插入->分批插入小部分数据;
```sql
-- 营房项目日志删除可以优化
delete from messages
where created < DATE_SUB(now(), interval 3 month);
-- 优化后
rows_affected = 0
do {
    rows_affected = do_query(
    "DELETE FROM messages where created < DATE_SUB(now(), interval 3 month) 
    LIMIT 10000"
    )
} while rows_affected > 0
```

### Join Decomposition
分解join的好处:
-- select * from tag where tag = 'mysql';
-- select * from tag_post where  tag_id=1234;
-- select * from post where post.id in (123,456,567,9098,8904);
- 缓存更高效. 比如第一条可能已经缓存了.再比如缓存了9098,8904,可以只查前三.
- 单独查表,可以减少锁表的情况.
- 更容易分库分表
- in比连表更快.
- 减少获取的重复数据,减少网络和内存使用.

:wusd
分解连表:
```sql
select * from tag
join tag_post on tag_post.tag_id = tag.id
join post on tag_post.post_id = post.id
where tag.tag = 'mysql';
-- 优化后
select * from tag where tag = 'mysql';
select * from tag_post where tag_id = 1234;
select * from post where post.id in (123,456,567,9098,8904);
```
1. 缓存更加高效了.比如缓存了9098,8904,可以只查前三个.
2. 查单表减少锁行.
3. 更易水平伸缩.
4. in()比连表更快
5. 减少重复数据获取,减少网络和内存使用.

## Query Execution Basics
client -> server -> engine -> server -> client
1. client -> server(SQL statement)
2. server parses, preprocesses, and optimizes into query execution plan
3. query execution engine executes the plan by calling the storage engine API
4. the server sends the result to the client

:wusd
query执行基础: query optimizer异常复杂和重要
1. client发送SQL到server
2. Parser转换SQL为Parse tree
3. Preprocessor对Parse tree进行优化
4. Query Optimizer把parse tree优化成query execution plan!!!
5. Query execution engine调用引擎接口执行plan
6. sever返回结果给client
 
### The MySQL Client/Server Protocol
通信协议是half-duplex,server要么发送,要么接受.因此无法把消息截断.
client/server发送/接受消息是单线程的.
client只能发一个包,因此设置max_allowed_packet很重要.
server则可能返回多个packet,但是一定会发送完,所以Limit很重要.
The client is "drinking from the fire hose".
大多数连接MySQL的库,要么只返回需要的数据,要么缓存下来.因为一旦请求了,MySQL会锁住行和相关资源,直到返回数据.

:wusd
MySQL client/server协议:
1. 通信协议是half-duplex,sever要么发送,要么接收.
2. client一次只能发送一个包,因此max_allowed_packet配置很重要,查询太大会报错
3. server可以返回多个packet,一定会全部发送完

### Query States
每个MySQL connection都有状态. 
这里对应就是展示所有连接.
SHOW FULL PROCESSLIST
Command列对应状态:
who has the ball
- Sleep: 等待client查询
- Query: 执行查询/返回数据给client
- Locked: 等待表锁,锁行不会造成这个问题
- Analyzing and statistics: 核对engine统计数据,优化查询
- Copying to tmp table [on disk]: 
  执行查询和复制结果到临时表,可能是group by, filesort, union.如果on disk结尾,则把临时表写入磁盘.
- Sorting result: 排序结果集

:wusd
查询状态: connection(thread)的状态,client和server谁有球?
- Sleep: 等待client查询
- Query: 执行查询/返回数据给client
- Locked: 等待表锁,锁行不会造成这个问题
- Analyzing and statistics: 检查engine统计数据,优化查询
- Copying to tmp table [on disk]:
  执行查询和复制结果到临时表,可能是group by, filesort, union.如果on disk结尾,则把临时表写入磁盘. 
- Sorting result: 排序结果集
```sql
-- 查询所有连接
show full processlist;
```

### The Query Optimization Process
把query转换成执行计划,有几步: 转化,预处理和优化.在这个过程错误会在这里抛出来.

:wusd
查询优化过程:
query转化成执行计划,有几步: 转换,预处理和优化.错误会在这个过程抛出来.

#### The parser and the preprocessor
MySQL parse把query分解成tokens,然后把token构建成parse tree.
Parser使用SQL语法去解析和校验查询,比如顺序,是否多引号等等.
Preprocessor再校验parse tree,比如名称和别名,确保没用ambiguous.
接着,preprocessor校验权限.

:wusd
parser和preprocessor:
parser:
1. 分解query成tokens,构建parse tree
2. 校验查询是否合法,比如顺序,引号有没有闭合等等
------
preprocessor:
1. 校验parse tree, 表和字段是否存在.名称和别名,确保不是ambiguous
2. 校验权限

#### The query optimizer
query可以有不同执行方法,得出相同的结果,optimizer找出最好的选项.
-- 检查cost, value是随机数据页数.
```sql
select SQL_NO_CACHE count(*) from film_actor;
show status like 'Last_query_cost';
```
随机数据页数取决于: 表或索引的行数,索引不同值的数量,行或键的长度,键的分布.
不一定都选择最佳计划的原因:
- 统计数据可能不对,因为MVCC的原因,行数不一定对.
- 预估不一定等于实际执行,因为有时候实际是顺序IO,有时候pages是在内存或磁盘中.
- MySQL的最佳策略不一定是我们的最佳策略,我们要快,它要损耗最小
- MySQL不考虑正在运行的query,会影响结果
- 有时候并不实际最优,只是按规则来的.比如优先用全文索引,实际上由普通索引.
- Mysql不考虑非自身的方法的损耗,比如自定义的方法
- optimizer不总是预估所有执行计划
优化分静态和动态(类似java反射)优化
优化:
- Reordering joins: 优化join顺序
- Converting OUTER JOINs to INNER JOIN: 有时候外联因为where的条件等于inner join
- Applying algebraic equivalence rules: 
  (5=5 and a > 5)->(a>5), ((a < b and b = c) and a = 5) -> b>5 and b=c and a =5
- count(),min(),max() optimization: 
  min直接用索引的最小值,max直接用索引的最大值. explain会显示Extra: Select tables optimized away.
- Evaluating and reducing constant expressions: 尽可能把不变的常数表达式计算出来
  有时候甚至直接把join变成单表查询.
- Covering index
- Subquery optimization: 
- Early termination: 提前终止,比如LIMIT.比如不可能的情况1=0,film_id=-1
  distinct, not exist(), left join
- Equality propagation: 等于的传播
- In() list comparisons: in的列表比较
  会先把list排序,然后再二分查找.

:wusd 常背
查询优化器:
- optimizer是cost-based的,先预估各个执行计划的cost,选择最小的执行计划.
- cost查询方式
```sql
select SQL_NO_CACHE count(*) from film_actor;
-- 查询cost
show status like 'last_query_cost';
```
- cost预估基于: 表和索引的页数,索引的不同值数,行和键的长度,键的分布.
- optimizer不能选择最优计划的原因:
  1. 预估使用的统计数据可能不对,比如因为MVCC的原因,行数不一定对.
  2. 预估指标不等于实际执行,有时候顺序IO,或者在内存中比实际要快很多.
  3. MySQL的cost和时间不等价
  4. MySQL不考虑其他同时运行的query,会影响结果
  5. MySQL不总是做cost-based优化,有时候机械执行规则.比如有时候普通索引比全文索引更优.
  6. MySQL不考虑非自身方法的额外开销,比如用户自定义的方法
  7. MySQL无法预估所有执行计划,所以miss了优化计划.
- 优化时期:
  1. 静态优化: 检查parse tree时
  2. 动态优化: 在每次查询后运行
-------
MySQL优化类型:
1. Reordering joins: 优化join顺序
2. 转化outer joins to inner join: 有时候外联因为where条件等于inner join
3. Applying algebraic equivalence rules: 优化一些算法表达式
   (5=5 and a > 5)->(a>5), ((a < b and b = c) and a = 5) -> b>5 and b=c and a =5
4. count(),min(),max() optimization: 直接用索引,不查表
   min直接用索引的最小值,max直接用索引的最大值. explain会显示Extra: Select tables optimized away.
5. Evaluating and reducing constant expressions: 计算和减少常量表达式,在连表会常量传播
```sql
-- film和film_actor的ref字段都是const
-- ref表示查询时,值的来源
explain select film.film_id, film_actor.actor_id from film
inner join film_actor using(film_id)
where film.film_id = 1;
```
6. Covering index: 覆盖索引,避免回表
7. Subquery optimization: 把一些子查询转换成索引查询
8. Early termination: 提前终止,比如LIMIT.比如不可能的情况1=0,film_id=-1.
    is null, distinct, not exist(), left join,(只要存在一个就满足该条件,会提前停止)
```sql
-- 逻辑矛盾 Extra: Impossible where
explain select film_id from film where film_id = -1;
-- 不存在行 Extra: no matching row in const table
explain select film_id from film where film_id = 0;
-- 只要film_actor.actor_id存在一个就会停止找下去
explain select film_id from film where film_id = -1;
select film_id from film
left join film_actor using(film_id)
where film_actor.actor_id is null;
```
9. Equality propagation: 等于的传播
```sql
select film_id from film
inner join film_actor using(film_id)
where film.film_id > 500;
-- 等价于上个查询,没有必要
select film_id from film
inner join film_actor using(film_id)
where film.film_id > 500 and film_actor.film_id > 500;
```
10. in() list comparisons: in的列表比较,先做排序,再二分查找

#### Table and index statistics
statistics不在server上,在engine上.
optimizer必须从engine获取statistics,才能选择最佳执行计划: 比如表或行的页数,表或索引的选择性,行或key的长度,key的分布.

:wusd
statistics不在server在engine上,所以optimizer必须从engine获取statistics,才能选择最佳执行计划.

#### MySQL's join execution strategy
MySQL认为一切都是join,包括单表查询,子查询.
MySQL执行UNION: 当作一系列单查,然后再把结果放入临时表,再读出来.
以前用的是嵌套join,现在改用了hash join.

:wusd
MySQL认为一切都是join,包括单表查询,子查询.
MySQL执行UNION: 当作一系列单查,然后再把结果放入临时表,再读出来.
以前版本用的是嵌套join,现在用hash join(放在内存中).

#### The execution plan
-- 如果show warnings,就可以看到重构的query
EXPLAIN EXTENDED [query]
join is not a balanced tree, is a left-deep tree.

:wusd
执行计划: MySQL join使用的是左深树.
```sql
-- 显示执行计划
explain analyze
select film_id from film
left join film_actor using(film_id)
where film_actor.actor_id is null;
```

#### The join optimizer
join优化: 当顺序无关结果时,MySQL会优化join顺序

:wusd
join优化: 当顺序无关结果时,MySQL会优化join顺序
n个表连接,就有n!种执行计划,所以optimizer_search_depth会限制深度,因此不一定能找到最优的计划.
left join时,不会做优化,因为其他表的结果依赖上一个表.(left join在写SQL除非必要,尽量不用)
```sql
explain 
select film.film_id, film.title, film.release_year,
       actor.actor_id, actor.first_name, actor.last_name from film
inner join film_actor using(film_id)
inner join actor using(actor_id);
explain
select straight_join film.film_id, film.title, film.release_year,
       actor.actor_id, actor.first_name, actor.last_name from film
inner join film_actor using(film_id)
inner join actor using(actor_id);
```

#### Sort optimizations
sort优化: 避免sort或者sort更少的行
MySQL不用索引产生排序结果,就得自己排序,无论在磁盘还是内存排序都叫filesort.
如果值能放到buffer中,MySQL用quicksort.如果不能就会分批快排,最后mergeSort.
filesort算法:
1. Two passes(old): 读row指针和排序字段,根据字段排序,最后再读row输出结果.因为第二读很多random IO,性能损耗大
2. Single pass(new): 读row需要的字段,然后排序,最后输出结果.只读一次.
连表排序: 如果只有一个表,先排序再join;如果多个表,先join再排序.

:wusd
sort优化: 避免filesort或sort更少的行
filesort: 
1. 定义: 如果不能用索引产生排序结果,就需要在磁盘或内存中排序,两者都是filesort.
2. 处理: 如果值能完全放入buffer中,用quicksort.如果不能,分批quicksort,最后mergesort.
filesort算法:
3. Two passes(old): 读ID和排序字段,排序,再根据ID读取所需字段输出结果.
    两次扫描表,速度慢
4. Single pass(new): 读所需字段,排序,输出结果.
    一次扫描表,速度快,占用空间大
5. 需要空间大,会使用字段的最大空间
   所以要正确设置字段大小
6. 如果排序字段在第一个表,先排序再join;如果排序字段不在第一个表,或者多表,先jion到临时表,再排序
    所以涉及到连表时,尽量让排序字段在第一个表

### The Query Execution Engine
每个table代表一个handler.
执行计划是一个数据结构,而不是执行字节码.
执行计划实现了数据引擎的handler接口,代表一个表.

:wusd
查询执行引擎: 按照执行计划进行查询.
执行计划是数据结构,而不是执行字节码.
执行计划实现了数据引擎的handler接口,代表一个表.优化器也使用执行计划获取表的列名和索引.

### Returning Results to the Client
server渐进地产生和返回结果.好处是client可以一行一行地接受处理.

:wusd
返回结果给客户端: MySQL处理完最后一张表,产生第一行数据,马上分包返回结果给Client.
好处:
1. server避免把结果保持在内存中
2. client尽快获取结果

## Limitations of the MySQL Query Optimizer
:wusd
MySQL只有少部分情况优化的不好

### UNION Limitations
union的外部限制条件,不会优化到内部
:wusd
UNION的limit: union外部的limit,不会优化到内部的表
```sql
-- 先查出actor和customer的所有,塞入临时表,再取出20行
(select first_name, last_name from actor
order by last_name)
union all
(select first_name, last_name from customer
order by last_name)
limit 20;
-- 先查出actor和customer的20行,总40行塞入临时表,再取出20行
(select first_name, last_name from actor
 order by last_name
 limit 20)
union all
(select first_name, last_name from customer
 order by last_name 
limit 20)
limit 20;
```


### Equality Propagation
=传播时,有可能把坏的条件传播给其他表.

:wusd
等式传播: where,on,using时,作用于A表的等式,传播给B表~C表.有可能把坏的等式给其他表.
    一般情况是好的,但是in()特别长时,那么就不好了
```sql
-- 查看执行计划
EXPLAIN FORMAT=JSON select t2.* from actor t1
left join film_actor t2 using(actor_id)
where t1.actor_id in ('1', '2', '3')
```

### Parallel Execution
MySQL一个query是串行的.

:wusd
MySQL的执行计划是串行的.

### SELECT and UPDATE on the Same Table
一张表不可以既查询又更新

:wusd
在同一张表上查询和更新:
```sql
-- 同时更新查询同一张表失败.一次更新一次查询所以失败.
-- 但是可以update不同的表,不过不推荐
update tbl as outer_tbl
set c = (select count(*) from tbl as inner_tbl
                         where inner_tbl.type=outer_tbl.type);
-- 改正:因为先执行子查询,生成了临时表,所以这次可以成功.
update tbl inner join (select type, count(*) as c from tbl group by type) as der
    on tbl.type=der.type
set tbl.c = der.c;
```

## Optimizing Specific Types of Queries
这些优化还得看MySQL版本

:wusd
优化特殊类型的查询:
这章的优化书里其他地方都有,但是这里做汇总供查阅.

### Optimizing COUNT() Queries
count()最容易被误解
:wusd
count()网上很多错误理解

#### What COUNT() does
count()分两种: count(row)和count(value),count是count不为null的值.
count(*),不是count所有列,而是count行,不需要优化.
count行时,应该始终使用count(*)

:wusd
count()怎么干的? count(columns...), count(*)
count(columns...): NULL值时不+1,有值时+1
count(*): 直接返回行数.
    因此计算行数时,永远用count(*)直接返回行数!!!

#### Simple optimizations
如何查多个不同条件的count:
1. select sum(if(color = 'blue', 1, 0)) as blue, sum(if(color = 'red', 1, 0)) as red from items;
2. select count(color = 'blue' or null) as blue, count(color = 'red' or null) as red from items;

:wusd
对同一字段不同值的计数
```sql
-- 查询不同色彩的数量
select sum(if(color = 'blue', 1, 0)) as blue, sum(if(color = 'red', 1, 0)) as red from items;
-- 查询不同色彩的数量
select count(color = 'blue' or null) as blue, count(color = 'red' or null) as red from items;
```

#### Using an approximation
如果只需要近似值,直接用explain就可以了.
如果只需要近似,有时候可以把distinct给移除掉.

:wusd
不需要准确数量时,可以用explain
```sql
-- rows
explain select * from actor;
```
可以去除distinct,避免filesort

#### More complex optimizations
除了covering index,没有太好的办法优化了.考虑加缓存吧.

:wusd
因为count()要count很多行,处理covering index没有太好的办法.
可以考虑在程序里加缓存,速度~简单~准确性,任选其二.
### Optimizing JOIN Queries
优化join:
- 确保连表字段有索引. 连A和B再column c上,加索引在第二张表上就可以了.
- 确保group by或order by的字段都在一张表,尝试用索引
- 升级MySQL注意join的语法

:wusd
优化连表查询:
- 连表时注意顺序,被连的表的字段最好有索引.
- group by和order by的字段尽量在一张表内,这样会用索引排序,而不是filesort

### Optimizing GROUP BY with ROLLUP
移除掉with ROLLUP

:wusd
优化带有ROLLUP的group by: 在程序里面做更高级的聚合.

### Optimizing LIMIT and OFFSET
分页涉及排序,排序最好支持索引方式.
分页问题,limit 10000,20.会生成10020rows,然后扔掉10000rows. 要么限制页码,要么使用更高效的offset.
limit 10000, 20: 生成10020行,扔掉10000行.如果所有页码都访问,那么平均下来每次扫半张表.
    要么页码大的不让访问,要么更高效的offset.
offset用covering index,而不是所有列.
```sql
-- offset用covering index
-- 有效是因为访问的55行不是从行里拿的,而是从索引里拿的
select film_id, description
from film inner join (
    select film_id from film order by title limit 50, 5
) as lim using(film_id);
```
把offset变成索引范围查询,需要提前计算和存储位置字段
```sql
-- position需要提前计算和存储
-- 不太实用,因为查询条件经常改变
select film_id, description
from film
where position between 50 and 54 order by position;
```
offset代表生成且删除的行,想法去掉offset.
```sql
-- 利用rental_id递增的特性
-- 第一次查询,得到rental_id是[16049...16030]
select * from rental
order by rental_id desc limit 20;
-- 第二次查询, 设置rental_id < 16030
select * from rental
where rental_id < 16030
order by rental_id desc limit 20;
```

:wusd
优化limit和offset: 分页涉及排序,排序字段最好有索引.
limit 10000,20: 生成10000+20行,扔掉10000行.造成分页查询平均每次扫半张表.
优化措施:
- 先子查询只查id(走covering index),再join其他字段
```sql
-- offset用covering index
-- 有效是因为访问的55行不是从行里拿的,而是从索引里拿的
select film_id, description
from film inner join (
    select film_id from film order by title limit 50, 5
) as lim using(film_id);
```
- 预先计算存储位置字段,把offset变成索引范围查询
```sql
-- position需要提前计算和存储
-- 不太实用,因为查询条件经常改变
select film_id, description
from film
where position between 50 and 54 order by position;
```
- 记录上次查询的结果,利用id递增特性,限制范围
```sql
-- 利用rental_id递增的特性
-- 第一次查询,得到rental_id是[16049...16030]
select * from rental
order by rental_id desc limit 20;
-- 第二次查询, 设置rental_id < 16030
select * from rental
where rental_id < 16030
order by rental_id desc limit 20;
```

### Optimizing SQL_CALC_FOUND_ROWS
SQL_CALC_FOUND_ROWS: 会告诉你有多少行,实际并不准确,只会告诉你需要的行数. 
更好的设计是只有下一页. 假如需要显示20行,那么查询21行,如果第21行是null,说明没有下一页.
直接查1000行,如果少于1000行,显示具体的分页.否则就显示超过1000行.
还可以用explain预估多少行,连google都不知道具体函数.你可以使用count(*)[有索引的情况]而不是用SQL_CALC_FOUND_ROWS.

:wusd
优化SQL_CALC_FOUND_ROWS
SQL_CALC_FOUND_ROWS: 告诉的行数不准确
下一页按钮: 查21行,显示20行,如果第21行是null,那么就没有下一页.
结果超过xx行: 查1000行,如果有1000行,则显示超过1000行;否则显示确切的结果.
explain快于count(covering index)快于SQL_CALC_FOUND_ROWS

### Optimizing UNION
用UNION ALL而不是UNION, UNION会去除重复的行,损耗相当大

:wusd
优化union:
- 优化器不会把union外部的条件加到内部,需要手动加(where,limit,order by)
- union会把所有的行放到临时表,然后去除重复的.所以尽量用union all.

## Summary
优化策略,不干,少干,干快点

:wusd
schema,index,query design三者对于优化查询来说,密不可分.
优化就三种方法: 不干,少干,干快点
# 6 Schema Design and Management
schema设计必须考虑查询,有些设计对某些查询优化,但是对另外一些操作性能低.

schema设计会随着业务的要求和存储的数据而变化.

..

逻辑设计,物理设计,查询执行.Schema,index,query optimization三者紧密关联.

## Choosing Optimal Data Types
任何数据类型都建议:
- 更小的数据类型: 
  选择最小的数据类型,越小占disk,memory,CPU cache越小.用越小的CPU.
- 更简单的数据类型:
    integer比characters好,因为characters比较时更复杂.
    eg. 1.时间用date或datetime而不是string 2.integers存IP而不是string
- 尽量避免NULL值:
    尽量不用NULL值,因为更耗空间,索引~索引统计数据~值比较时也需要特殊处理
数字,字符串,时间选择字段很直观,有些情况不那么直观.
有些数据类型存储相同的数据,但是大小~精度~存储空间要求不一样.有些数据类型有特殊行为.
DATETIME vs TIMESTAMP: TIMESTAMP只用一半空间,还有自动更新特性.但是值范围小,并且特性有可能是麻烦.
类型别名不影响实际类型.
:wusd----------
如何选择数据类型? 更小,更简单,避免NULL值.

## Whole Numbers
integer: tinyint~smallint~mediumint~int~bigint 8~16~24~32~64b=1~2~3~4~8B
可以设置为unsigned,只能存自然数,容量不变
..
Number类型的计算都是用bigint来计算的(Decimal和Double除外)
int(1)==int(20)

## Real Numbers
decimal还可以用于比bigint还大的数
float和double用的是标准浮点算术
只能存不准确的数据
Float: 4bytes, Double: 8bytes
Decimal需要更大空间,更多计算消耗.所以除非是精确要求的(钱),否则最好不用.
## String Types
每个string字段都有自己的字符集和排序规则
### VARCHAR and CHAR types
..
..
VARCHAR:
长度可变,因此比CHAR存储空间小
长度255则+1byte,长度更多则+更多byte
因为长度会变化,如果过长了,InnoDB会分页
字段变化少,字段最大长度比平均长度大很多,适合使用.
..
CHAR:
存储空间固定.存储时去除末尾的空格,比较时补全空格.
CHAR适用场景: 
 1. MD5 固定长度
 2. 字段经常改变 不易碎片化
 3. Y~N 只需要1byte,varchar需要2bytes
..
..
..
binary 和 varbinary行为类似,但是binary不存储空格,存储\0, 也不去除\0当查询时. 
binary直接比较数字,比字符串的比较要快.

## BLOB and TEXT types
BLOB和TEXT用于存储binary或strings
..
BLOB和TEXT有独立标识,当很大时,会单独存储.
BLOB和TEXT的区别,BLOB存储binary,TEXT存储strings
BLOB和TEXT排序只排序[max_sort_length]之类的数据
..
## Using ENUM instead of a string type
ENUM 1-2bytes,取决于值的数字值大小
..
..
..
..
..
enum连char和varchar比char和varchar连enum慢
## Date and Time Types
最好能存毫秒,Datetime和timestamp都可以存日期+时间.
DATETIME:
精确到毫秒级, YYYYMMDDHHHMMSS格式, 8bytes, 无视时区.可以排序,无歧义.
TIMESTAMP:
精确到毫秒级, 从1970GMT, 4bytes. 依赖时区,需要设置.可以配置插入/更新时更新当前时间戳.
## Bit-PACKED Data Types
Mysql有几个类型支持单独的bits存储数据,实际上都是strings.

### BIT
使用固定空间,存储一个个单独的是否(10), BIT(1)1byte, BIT(2)2byte, BIT(3)3byte, BIT(4)4byte, BIT(5)5byte...
BIT(8)存储b'00111001'(binary是57,而ascii对应字符是9).
最好别用,容易出错.
可以用char(0),存null或''.最好用tinyint

### SET
要存很多true和false,可以用SET.搭配find_in_set(),field()使用.
### Bitwise operations on integer columns
可以用tinyint,然后用bitwise的操作.
修改和查询麻烦.
...
## JSON Data
JSON存数据库是antipattern的,理想情况下schema就代表了JSON.
JSON数据对比结构化数据,存储空间要大,因为存储了很多添加的信息去定义JSON.
JSON查询和普通都非常快,尽管JSON要多一倍的时间.
如果加了索引,SQL会更快,因为索引允许只返回1行,而不是全部.
JSON的生成字段,也可以加索引,几乎和SQL查询差不多
## Choosing Identifiers
主键代表一行,有可能用在多个表里面当作主键.
主键的类型非常重要,因为主键会用于比较和join.
要考虑MySQl如何计算和比较主键,比如ENUM和Set存储的是int,但是比较的是字符串.
一旦选择了类型,在其他表应该用相同的类型,避免性能问题.
选择最小的类型,但是保留增长的可能.因为主键还会存储到其它表中,会产生巨大的影响.
### Integer types
主键的最好选择(快且自动递增),但是要注意不要用光了integer.

### ENUM and SET
比较差的选择,一般用于订单状态和产品类型.

### String types
尽可能避免使用String,空间大,插入和查询慢.
插入慢: 因为需要随机位置去索引,造成分页
查询慢: 在磁盘和内存中分散.
如果普遍用UUID,尽量转换成UNHEX()
## Special Types of Data
IP地址实际是int unsigned, 192.xx.xx.xx只是为了好看.
可以用INET_ATON()和INET_NTOA()转化
## Schema Design Gotchas in MySQL
有些问题产生于MySQL独特的实现.

### Too Many Columns
InnoDB在server和storage engine用行缓存复制数据,这种复制涉及到数据转化.字段越多,复制就越困难.

### Too Many Joins
MySql限制了最多61个jion.

### The All-Powerful ENUM
ENUM的值太多了

### The ENUM in Disguise
类型是SET,实际只能有一个值时.

### NULL Not Invented Here
可以用0或''代替NULL.
但是用上面的方法,也会增加代码复杂度.
MySQL索引NULL值
迭代Schema设计: schema management

## Schema Management
人多了,维护schema会很麻烦.最好是不允许手动修改.


## Summary
总之,尽量让事情简单.
- 避免极端设计,比如一个表大量的字段.
- 使用小~简单~合适的数据类型,避免使用NULL除非model你的现实.
- 用相同的数据类型存储相似~相关的数据,尤其是有join.
- 小心可变String,可能造成全长临时表和排序.
- id尽量用integer
- 小心MySQL的遗留问题,比如float丢失精度
- 小心ENUM和SET,BIT最好不用.
Schema随着你的业务和用户会进化,考虑用Schema Management使得进化安全和可伸缩.


# 6 Schema Design and Management
schema的设计必须考虑查询.有些对查询优化,对其他就性能低.eg.增加counter和summary表查询快,维护起来就麻烦.
schema会随着业务和数据的变化,查询方式变化而变化.
..
逻辑设计,物理设计,查询执行.Schema,index,query optimization三者紧密关联.

:wusd
schema设计和管理
1. schema的设计必须结合查询,schema会随着业务~数据~查询方式变化而变化.
2. schema,index,query optimization三者紧密相连,需要时时回顾.

## Choosing Optimal Data Types
任何数据类型都建议:
- 更小的数据类型: 
  选择最小的数据类型,越小占disk,memory,CPU cache越小.用越小的CPU.
- 更简单的数据类型:
    integer比characters好,因为characters比较时更复杂.
    eg. 1.时间用date或datetime而不是string 2.integers存IP而不是string
- 尽量避免NULL值:
    尽量不用NULL值,因为更耗空间,索引~索引统计数据~值比较时也需要特殊处理
数字,字符串,时间选择字段很直观,有些情况不那么直观.
有些数据类型存储相同的数据,但是大小~精度~存储空间要求不一样.有些数据类型有特殊行为.
DATETIME vs TIMESTAMP: TIMESTAMP只用一半空间,还有自动更新特性.但是值范围小,并且特性有可能是麻烦.
类型别名不影响实际类型.

:wusd
选择最优的数据类型:
- 更小: 
  + 数据类型越小,Disk~memory~CPU cycle就越小
  + 要小,但是也要足够大容纳你的数据
  + 如果前期不知道多大,尽可能小,后期扩大也方便
- 更简单:
  + 越简单计算时需要的操作越少,integer比较就比characters快
  + 时间和日期用内置的时间类型,而不是string
  + ip用integer而不是string
- 尽可能避免NULL值:
  + NULL值让索引,索引统计数据,值比较更复杂,也使用更多空间和特殊操作
  + 但是NULL和没NULL值性能差别小,不要特意去把已经是NULL值改成没NULL值.
- DATETIME vs TIMESTAMP:
  + 5~8Byte vs 4Byte: timestamp最大范围到2038年
  + tm更新时间戳特性,dt也有这个特性,但有时是问题
  + tm时区敏感,dt时区不敏感
```sql
drop table if exists time_test;
create table time_test(
    dt_col datetime on update current_timestamp default current_timestamp,
    tm_col timestamp
);
insert time_test(dt_col, tm_col) values (null, now());
```

## Whole Numbers
integer: tinyint~smallint~mediumint~int~bigint 8~16~24~32~64b=1~2~3~4~8B
可以设置为unsigned,只能存自然数,容量不变
..
Number类型的计算都是用bigint来计算的(Decimal和Double除外)
int(1)==int(20)

:wusd
整数:
- tinyint~smallint~mediumint~int~bigint: 存储1~2~3~4~8B,对应-2^7--2^7-1
- tinyint unsigned: 0~255,只需要正数时,只用unsigned
- int(1)等价于int(20)
- integers比较时,用的是bigint

## Real Numbers
decimal还可以用于比bigint还大的数
float和double用的是标准浮点算术
浮点型只能存不准确的数据
Float: 4bytes, Double: 8bytes
Decimal需要更大空间,更多计算消耗.所以除非是精确要求的(钱),否则最好不用.

:wusd
实数:
- decimal: 当数字比bigint还大时,或者需要准确的小数
- float 和 double: 4B和8B, 只能存不准确的小数
- bigint: 可以使用把小数乘以1000,存取为bigint

## String Types
每个string字段都有自己的字符集和排序规则

:wusd
String 类型:
每个string字段有自己的字符集合和排序规则
### VARCHAR and CHAR types
..
VARCHAR和CHAR可能在磁盘和内存上不一样,到了Server以后又不一样.



- VARCHAR
只使用需要的长度,因此比CHAR存储空间小
varchar需要额外的空间存储值得长度. 1byte最多存255byte,1000byte字符则需要1002byte空间.(所以remark应该长度255)
varchar字段的长度变化,可能到导致分页.
字段变化少,字段最大长度比平均长度大很多,适合使用.
长varchar还会被存储于BLOBs

- CHAR
存储空间固定.存储时去除末尾的空格,比较时补全空格.
CHAR适用场景: 
 1. 字段少,且经常改变
 2. MD5 固定长度
 3. 字段经常改变 不易碎片化
 4. Y~N 只需要1byte,varchar需要2bytes
..
..
..
wusd:
CHAR定长,存储时去除末尾空格,比较时补全空格.
适用场景: 固定长度,字段经常改变,小长度的值(比varchar省空间)

binary 和 varbinary行为类似,但是binary不存储空格,存储\0, 也不去除\0当查询时. 
binary直接比较数字,比字符串的比较要快.

用varchar(5)比varchar(255)要好,虽然存储空间一样,但是计算时后者占用空间大.
所以最好最小的类型.

:wusd
varchar和char:
varchar:
- 存储空间不固定: 只使用存储的空间和描述存储的空间
- 额外存储空间: 1B对应varchar(255)以内,2B对应varchar(65535)以内
- varchar(255) vs varchar(40): 存储同样内容时,存储一样,但是比较时前者大
- 如果字段值的长度改变,而原有空间不足,会导致分页
- 适用场景: 字段长度变化少,最大长度远大于平均长度
char:
- 存储空间固定: 存储时去除末尾空间,比较时补全末尾空格
```sql
-- char存储时去除末尾空格
drop table if exists char_test;
create table char_test(char_col char(10));
insert into char_test(char_col) values 
    ('string1'),(' string2'), ('string3 ');
select concat("'", char_col, "'") from char_test;
-- varchar不会去除末尾空格
drop table if exists varchar_test;
create table varchar_test(varchar_col varchar(10));
insert into varchar_test(varchar_col) values
    ('string1'),(' string2'), ('string3 ');
select concat("'", varchar_col, "'") from varchar_test;
```
- 适用场景: 字段长度固定,字段长度经常改变,字段长度小(比如Y/N)
binary 和 varbinary: 与char和varchar类似,区别在于存储的是数字,补全空白是\0

## BLOB and TEXT types
BLOB和TEXT用于存储binary或strings
TINYTEXT~SMALLTEXT~TEXT(SMALLTEXT)~MEDIUMTEXT~LONGTEXT TINYBLOB~SMALLBLOB~BLOB(SMALLBLOB)~MEDIUMBLOB~LONGBLOB
BLOB和TEXT有独立标识,当很大时,会单独存储.
BLOB和TEXT的区别,BLOB存储binary,TEXT存储strings
BLOB和TEXT排序只排序[max_sort_length]前缀的数据
..

:wusd
BLOB(Binary Large Object)和TEXT:
- TINYTEXT~SMALLTEXT~TEXT(SMALLTEXT)~MEDIUMTEXT~LONGTEXT
- TINYBLOB~SMALLBLOB~BLOB(SMALLBLOB)~MEDIUMBLOB~LONGBLOB
- BLOB和TEXT当很大时,会单独存储
- BLOB和TEXT排序只排序[max_sort_length]前缀的数据
- BLOB存储binary,TEXT存储strings
## Using ENUM instead of a string type
ENUM 1-2bytes,取决于值的数字值大小
..
..
..
..
..
enum连char和varchar比char和varchar连enum慢

:wusd
...
## Date and Time Types
最好能存毫秒,Datetime和timestamp都可以存日期+时间.
DATETIME:
精确到毫秒级, 存储YYYYMMDDHHHMMSS数字, 8bytes, 依赖时区.可以排序,无歧义.
TIMESTAMP:
精确到毫秒级, 从1970GMT, 4bytes. 依赖时区,需要设置.可以配置插入/更新时更新当前时间戳.

:wusd
...
```sql
drop table if exists time_test;
create table time_test
(
    datetime_col  datetime  null,
    timestamp_col timestamp null
);
-- timestamp有时区,datetime无时区
insert into time_test
values ('2020-01-01 00:00:00', '2020-01-01 00:00:00');
SET time_zone = '+08:00';
select * from time_test;
-- timestamp存储不了2038之后的数据
insert into time_test
    values ('2020-01-01 00:00:00', '2039-01-01 00:00:00');
```
## Bit-PACKED Data Types ...
Mysql有几个类型支持单独的bits存储数据,实际上都是strings.

### BIT
使用固定空间,存储一个个单独的是否(10), BIT(1)1byte, BIT(2)2byte, BIT(3)3byte, BIT(4)4byte, BIT(5)5byte...
BIT(8)存储b'00111001'(binary是57,而ascii对应字符是9).
最好别用,容易出错.
可以用char(0),存null或''.最好用tinyint

### SET
要存很多true和false,可以用SET.搭配find_in_set(),field()使用.
### Bitwise operations on integer columns
可以用tinyint,然后用bitwise的操作.
修改和查询麻烦.
...
## JSON Data
JSON存数据库是antipattern的,理想情况下schema就代表了JSON.
JSON数据对比结构化数据,存储空间要大,因为存储了很多添加的信息去定义JSON.
JSON查询和普通都非常快,尽管JSON要多一倍的时间.
如果加了索引,SQL会更快,因为索引允许只返回1行,而不是全部.
JSON的生成字段,也可以加索引,几乎和SQL查询差不多.

:wusd
JSON数据: 
- 存储比结构化大
- 无索引查询虽然比SQL多一倍时间,但仍然很快.
- 可以生成字段,加索引.几乎和SQL查询一样快.
- 应用: 其实文俊可以用JSON,而不是ES. JSON的字段可以用headerPath. 速度和MySQL几乎差不多
```sql
desc asteroids_json;
desc asteroids_sql;
show table status;
-- JSON查询单字段
select json_data->'$.designation' from asteroids_json;
-- JSON增加虚拟字段,加索引
alter table asteroids_json add column designation varchar(30) generated always as
    json_data->'$.designation', add index(designation);
select * from asteroids_json where designation = '"419880 (2011 AH37)"';
```

## Choosing Identifiers
主键代表一行,有可能用在多个表里面当作主键.
主键的类型非常重要,因为主键会用于比较和join,也会用在其他表当外键.
要考虑MySQl如何计算和比较主键,比如ENUM和Set存储的是int,但是比较的是字符串.
一旦选择了类型,在其他表应该用相同的类型,避免性能问题.
选择最小的类型,但是保留增长的可能.因为主键还会存储到其它表中,会产生巨大的影响.


### Integer types
主键的最好选择(快且自动递增),但是要注意不要用光了integer.

### ENUM and SET
比较差的选择,一般用于订单状态和产品类型.

### String types
尽可能避免使用String,空间大,插入和查询慢.
插入慢: 因为需要随机位置去索引,造成分页~随机IO~集群索引碎片
查询慢: 在磁盘和内存中分散.
因为值分散,容易造成缓存miss
如果普遍用UUID,存储UNHEX()转成Binary(16),再用HEX()返回.
:wusd
之前用UUID当ID是错误的,但是要怎么样重构?

:wusd
主键选择:
- 尽量选择最小类型的主键,但是保留增长可能
- 在所有相关表里面,保持类型相同(包括unsigned),避免计算/比较时的性能问题
- 应用:
  + Integer类型: int自增(小心用光id),bigint雪花算法(分布式)
  + ENUM和SET: 不考虑
  + String类型: 当心随机值MD5,UUID
    + 尽可能避免,比int慢且空间大.
    + 插入慢: 随机位置索引,造成分页~随机IO~集群索引碎片
    + 查询慢: 逻辑相邻的数据在磁盘和内存中分散
    + 缓存flushes和miss: 因为随机,缓存没有热点区域
    + 如何必须用UUID,用HEX()转成Binary(16)存储,再用HEX()返回.

## Special Types of Data
IP地址实际是int unsigned, 192.xx.xx.xx只是为了好看.
可以用INET_ATON()和INET_NTOA()转化

:wusd
- IPv4实际是int unsigned, 192.xx.xx.xx只是为了好看.
- 可以用INET_ATON()和INET_NTOA()转化

## Schema Design Gotchas in MySQL
有些问题产生于MySQL独特的实现.

### Too Many Columns
InnoDB在server和storage engine用行缓存复制数据,这种复制涉及到数据转化.字段越多,复制就越困难.

### Too Many Joins
MySql限制了最多61个jion.

### The All-Powerful ENUM
ENUM的值太多了

### The ENUM in Disguise
类型是SET,实际只能有一个值时.

### NULL Not Invented Here
可以用0或''代替NULL.
但是用上面的方法,也会增加代码复杂度.
MySQL索引NULL值
迭代Schema设计: schema management

:wusd
schema设计MySQL通病:
- 表字段太多,MySQL8.0前,engine会传递server所有字段,MySQL8.0后,engine只传递需要的字段
- 太多连表
- 枚举值太多
- 表面是SET,实际值少,是枚举
- 强行不用NULL,用一些默认值代替,导致代码复杂

## Schema Management
人多了,维护schema会很麻烦.最好是不允许手动修改.


## Summary
总之,尽量让事情简单.
- 避免极端设计,比如一个表大量的字段.
- 使用小~简单~合适的数据类型,避免使用NULL除非model你的现实.
- 用相同的数据类型存储相似~相关的数据,尤其是有join.
- 小心可变String,可能造成全长临时表和排序.
- id尽量用integer
- 小心MySQL的遗留问题,比如float丢失精度
- 小心ENUM和SET,BIT最好不用.
Schema随着你的业务和用户会进化,考虑用Schema Management使得进化安全和可伸缩.

:wusd
schema设计尽可能少而简单.
- 避免极端设计,eg表字段太多
- 适用小~简单~合适的数据类型,避免NULL除非数据就是要NULL值
- 相同数据在不同表用相同的数据类型,尤其有join
- 小心varchar,可能造成全长临时表和排序
- id尽量用integer
- 小心float~double丢失精度
- 小心ENUM和SET,BIT最好不用.


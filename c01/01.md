# 1 MySQL架构
MySQL架构,存储引擎
## MySQL的逻辑架构
客户端->[连接/线程处理->解析器->优化器]->存储引擎

客户端: 连接处理~身份验证~安全
第二层[连接/线程处理->解析器->优化器]: 查询解析~分析~优化~内置函数,跨引擎功能(存储过程~触发器~视图)
存储引擎: 数据存取, 通过存储API

- 连接管理与安全性: 
  1. 一个连接一个线程,线程留在一个CPU内核上. 服务器有个线程池,会缓存线程
  2. 身份验证, 每次查询会验证权限
- 优化与执行:
    1. 创建解析树,进行优化(重写查询~表的读取顺序~索引选择)A
    2. 查询缓存(8.0移除),在redis缓存

## 并发控制
只要多个查询同时修改,就需要并发控制
服务器级别 和 存储引擎级别 并发控制

### 读写锁
共享锁(shared lock): 读锁(read lock)
排他锁(exclusive lock): 写锁(write lock)

### 锁的粒度
尽量只锁需要修改的数据,管理锁本身也耗资源

锁策略:
表锁(table lock): 锁管理开销最小.写锁整张表其他线程的所有操作. 读锁不可修改,但是其他线程可以操作
行锁(row lock): 锁管理开销大.在存储引擎中实现

## 事务
事务的一组语句,要么都成,要么都失败
### ACID
- 原子性atomicity: 一组操作要么全部成功,要么全部失败
- 一致性consistency: 事务开始时和结束时,数据保持一致
- 隔离性isolation: 事务A还未提交前,事务B不能读取事务A的数据
- 持久性durability: 事务成功后,数据持久化

### 隔离级别
事务A,事务B,事务C
- Read UnCommitted:脏读1,不可重复读1,幻读1,加锁读0. 
  B可以读到A未提交的数据.
- Read Committed:脏读0,不可重复读1,幻读1,加锁读0. 
  读已提交. A第一次已提交是0,第二次已提交是100. B两次读A,有可能是0,也可能是100.
- Repeatable Read(MySQL级别):脏读0,不可重复读0,幻读1,加锁读0
  可重复读.挡不住读幻. A第一次已提交是0,第二次已提交是100. B两次读A,要么是0,要么是100(会给你保存下来).
- Serializable:脏读0,不可重复读0,幻读0,加锁读1  所有事务按序执行,解决了幻读问题.
### 死锁
循环依赖
```sql
start transaction;
update stockPrice set close = 45.50 where stock_id = 4 and date = '2020-05-01;'
update stockPrice set close = 19.80 where stock_id = 3 and date = '2020-05-02;'
commit;

start transaction;
update stockPrice set close = 20.12 where stock_id = 3 and date = '2020-05-02;'
update stockPrice set close = 47.20 where stock_id = 4 and date = '2020-05-01;'
  commit;
```
### 事务日志
1. 事务未完成前,只改内存数据
2. 追加写
### MySQL中的事务
#### AUTOCOMMIT
单个insert~update~delete默认事务.如果不设置,就需要手动commit

#### 在事务中混合使用存储引擎
最好别

#### 隐式锁定和显式锁定


## 多版本并发控制 MVCC
乐观并发控制
悲观并发控制

## 复制
一主多副(二进制日志)


## 数据文件结构
表的元数据: .ibd
## InnoDB引擎

## 小结
Mysql架构:
- 上层:服务和查询执行层
- 下层:存储引擎
存储引擎的API最重要

表元数据~用户认证~身份鉴权
原子DDL

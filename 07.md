# 7 Indexing for High Performance
索引是存储引擎用来快速找行的.
数据量小没有索引也很快,数据量一大性能迅速下降.差索引是现实中首要的性能问题的原因.
索引优化会提升性能,但是需要你重写查询.所以本章和下章关联.

## Indexing Basics
Types of indexes? B-tree(Adaptive hash index), full-text indexes
Benefits of Indexes? navigate, order up, group by, index only queries

书找主题: 直接去索引页找相应的页码.
MySQL先在索引找这个值,通过索引找到对应的行.
索引只会在找最左边的值较为高效,所以涉及到多个字段的,顺序很重要.

### Types of Indexes
有很多索引类型,同一种类型不同引擎可能实现方式都不一样.
#### B-tree indexes
MySQL使用B-tree创建表.
B-tree:所有的leaf页和Root的距离都是相同的.
B-tree之所以快,因为不用全表扫,对数级别找到包含这个值的node,然后从node开始找.
树的深度取决于表的大小.
因为B-trees按顺序存储数据,所以找范围数据非常有用.比如: 搜索K打头的名字.

##### Adaptive hash index
如果某个值经常被查找,会创建hash表,存储这个值和相应的位置.(类似缓存)

##### Types of queries that can use a B-tree index
B-tree索引在找全值~找范围值~找左前缀效果很好.
以people表为例: key(last_name, first_name, dob)
- Match the full value: last name, first name, dob(所有字段)
- Match a leftmost prefix: last name(只用第一个字段)
- Match a column prefix: last names begin with J(第一个字段的前缀)
- Match a range of values: last name between Allen and Barrymore(范围)
- Match one part exactly and match a range on another part: last_name(match), first_name(range)
- Index-only queries: 只查索引页
因为B-tree是有序的,所以排序也有用.
B-tree indexes的限制:这里的问题我的mysql版本都没有了
- first name为Bill~dob为特定值的,因为不是最左边的字段; last name以z结尾的也不走索引.
- 不能省略字段,只用两字段是不走索引的
- 涉及右模糊查询不会优化. where last_name = 'Smith' and first_name like 'J%' and dob = '1980-01-01'也不走索引.

#### Full-text indexes
全文索引用的是分词而不是全文,有很多处理: 复数~布尔等等.
full-text不会取消B-tree索引.全文索引用于match而不是where.
B树把数据按有序的方式组织起来,query~order by~group by都受益.Index还会存储值的副本,所以有些值直接在索引可以拿到.
三大好处:
1. Indexes减少server要检查的数据量
2. Indexes避免server sorting和创建临时表
3. Indexes把随机IO转换成序列IO
----
index 3星法则:
1. 索引把相关的行放在一起
2. 行的排序是查询所需要的
3. 它包含查询需要的所有行.

## Indexing Strategies for High Performance
index strategies?

有很多方式选择和高效使用索引,因为有很多的特殊场景优化和特殊行为.

### Prefix Indexes and Index Selectivity
只索引前缀一般要好于索引全值.选择性(索引值数/总行数),从1/#T to 1.
前缀的选择性已经足够好了,当BLOB和text必须索引前缀,因为MySQL不允许索引全值.
索引前缀要做到有足够的选择性,又不至于太长来节约空间.
索引前缀可以让索引变小变快,但是不能用于排序~分组,也不能用于覆盖索引.
索引前缀的场景: 16进制的ID,比如sessionId.索引变小变快了.

### Multicolumn Indexes

### Choosing a Good Column Order

### Clustered Indexes

### Covering Indexes

### Using Index Scans for Sorts

### Redundant and Duplicate Indexes

### Unused Indexes

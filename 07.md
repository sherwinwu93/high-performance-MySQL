# 7 Indexing for High Performance
索引是存储引擎用来快速找行的.
数据量小没有索引也很快,数据量一大性能迅速下降.差索引是现实中首要的性能问题的原因.
索引优化会提升性能,但是需要你重写查询.所以本章和下章关联.

## Indexing Basics
Types of indexes? B-tree(Adaptive hash index), full-text indexes
Benefits of Indexes? navigate, order up, group by, index only queries

书找主题: 直接去索引页找相应的页码.
MySQL先在索引找这个值,通过索引找到对应的行.
索引只会在找最左边的值较为高效,所以涉及到多个字段的,顺序很重要.

### Types of Indexes
有很多索引类型,同一种类型不同引擎可能实现方式都不一样.
#### B-tree indexes
MySQL使用B-tree创建表.
B-tree:所有的leaf页和Root的距离都是相同的.
B-tree之所以快,因为不用全表扫,对数级别找到包含这个值的node,然后从node开始找.
树的深度取决于表的大小.
因为B-trees按顺序存储数据,所以找范围数据非常有用.比如: 搜索K打头的名字.

##### Adaptive hash index
如果某个值经常被查找,会创建hash表,存储这个值和相应的位置.(类似缓存)

##### Types of queries that can use a B-tree index
B-tree索引在找全值~找范围值~找左前缀效果很好.
以people表为例: key(last_name, first_name, dob)
- Match the full value: last name, first name, dob(所有字段)
- Match a leftmost prefix: last name(只用第一个字段)
- Match a column prefix: last names begin with J(第一个字段的前缀)
- Match a range of values: last name between Allen and Barrymore(范围)
- Match one part exactly and match a range on another part: last_name(match), first_name(range)
- Index-only queries: 只查索引页
因为B-tree是有序的,所以排序也有用.
B-tree indexes的限制:这里的问题我的mysql版本都没有了
- first name为Bill~dob为特定值的,因为不是最左边的字段; last name以z结尾的也不走索引.
- 不能省略字段,只用两字段是不走索引的
- 涉及右模糊查询不会优化. where last_name = 'Smith' and first_name like 'J%' and dob = '1980-01-01'也不走索引.

#### Full-text indexes
全文索引用的是分词而不是全文,有很多处理: 复数~布尔等等.
full-text不会取消B-tree索引.全文索引用于match而不是where.
B树把数据按有序的方式组织起来,query~order by~group by都受益.Index还会存储值的副本,所以有些值直接在索引可以拿到.
三大好处:
1. Indexes减少server要检查的数据量
2. Indexes避免server sorting和创建临时表
3. Indexes把随机IO转换成序列IO
----
index 3星法则:
1. 索引把相关的行放在一起
2. 行的排序是查询所需要的
3. 它包含查询需要的所有行.

## Indexing Strategies for High Performance
index strategies?

有很多方式选择和高效使用索引,因为有很多的特殊场景优化和特殊行为.

### Prefix Indexes and Index Selectivity
只索引前缀一般要好于索引全值.选择性(索引值数/总行数),从1/#T to 1.
前缀的选择性已经足够好了,当BLOB和text必须索引前缀,因为MySQL不允许索引全值.
索引前缀要做到有足够的选择性,又不至于太长来节约空间.
索引前缀可以让索引变小变快,但是不能用于排序~分组,也不能用于覆盖索引.
索引前缀的场景: 16进制的ID,比如sessionId.索引变小变快了.

### Multicolumn Indexes
多列经常犯的错: 单独索引很多字段;索引错误顺序的字段
为where子句出现的字段创建索引. 这句话是错误的,如果不能设计3星索引(2星),最好无视where子句,创建覆盖索引去优化.
单独的多个列索引,大多数情况不会改善性能.在OR和AND的情况下,会各自走索引,最后再index merge(or-union,or-intersection).
index merge有时很有用,但大多数是poorly index的指示器.
- intersecting indexes时(and), 你实际只需要一个索引
- union indexes时(or), 算法缓存,排序~归并使用很多CPU和内存
- 有时候过度索引,可能还不如单表扫描.

### Choosing a Good Column Order
小心选择索引顺序,使得行是排列和分组好的,可以有益于查询.
索引是按最左边的字段,再往右.所以正序或逆序在query, order by, group by和distinct被使用.
把选择性最大的列放在最左边. 有些情况有用,但是避免不了random IO,排序.
这条建议确实优化where查询,但还要看实际值的分布(index prefix).
因为用索引前缀,问题经常来自于特殊的值(有更高的独特性).比如: 匿名用户sessionId.
这些建议确实有用,但是不能假设所有的情况都是平均情况,特殊情况可能降低整个应用的性能.

### Clustered Indexes

### Covering Indexes

### Using Index Scans for Sorts

### Redundant and Duplicate Indexes

### Unused Indexes

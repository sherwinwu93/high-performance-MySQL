# 7 Indexing for High Performance
索引是存储引擎用来快速找行的.
数据量小没有索引也很快,数据量一大性能迅速下降.差索引是现实中首要的性能问题的原因.
索引优化会提升性能,但是需要你重写查询.所以本章和下章关联.

## Indexing Basics
Types of indexes? B-tree(Adaptive hash index), full-text indexes
Benefits of Indexes? navigate, order up, group by, index only queries

书找主题: 直接去索引页找相应的页码.
MySQL先在索引找这个值,通过索引找到对应的行.
索引只会在找最左边的值较为高效,所以涉及到多个字段的,顺序很重要.

### Types of Indexes
有很多索引类型,同一种类型不同引擎可能实现方式都不一样.
#### B-tree indexes
MySQL使用B-tree创建表.
B-tree:所有的leaf页和Root的距离都是相同的.
B-tree之所以快,因为不用全表扫,对数级别找到包含这个值的node,然后从node开始找.
树的深度取决于表的大小.
因为B-trees按顺序存储数据,所以找范围数据非常有用.比如: 搜索K打头的名字.

##### Adaptive hash index
如果某个值经常被查找,会创建hash表,存储这个值和相应的位置.(类似缓存)

##### Types of queries that can use a B-tree index
B-tree索引在找全值~找范围值~找左前缀效果很好.
以people表为例: key(last_name, first_name, dob)
- Match the full value: last name, first name, dob(所有字段)
- Match a leftmost prefix: last name(只用第一个字段)
- Match a column prefix: last names begin with J(第一个字段的前缀)
- Match a range of values: last name between Allen and Barrymore(范围)
- Match one part exactly and match a range on another part: last_name(match), first_name(range)
- Index-only queries: 只查索引页
因为B-tree是有序的,所以排序也有用.
B-tree indexes的限制:这里的问题我的mysql版本都没有了
- first name为Bill~dob为特定值的,因为不是最左边的字段; last name以z结尾的也不走索引.
- 不能省略字段,只用两字段是不走索引的
- 涉及右模糊查询不会优化. where last_name = 'Smith' and first_name like 'J%' and dob = '1980-01-01'也不走索引.

#### Full-text indexes
全文索引用的是分词而不是全文,有很多处理: 复数~布尔等等.
full-text不会取消B-tree索引.全文索引用于match而不是where.
B树把数据按有序的方式组织起来,query~order by~group by都受益.Index还会存储值的副本,所以有些值直接在索引可以拿到.
三大好处:
1. Indexes减少server要检查的数据量
2. Indexes避免server sorting和创建临时表
3. Indexes把随机IO转换成序列IO
----
index 3星法则:
1. 索引把相关的行放在一起
2. 行的排序是查询所需要的
3. 它包含查询需要的所有行.

## Indexing Strategies for High Performance
index strategies?

有很多方式选择和高效使用索引,因为有很多的特殊场景优化和特殊行为.

### Prefix Indexes and Index Selectivity
只索引前缀一般要好于索引全值.选择性(索引值数/总行数),从1/#T to 1.
前缀的选择性已经足够好了,当BLOB和text必须索引前缀,因为MySQL不允许索引全值.
索引前缀要做到有足够的选择性,又不至于太长来节约空间.
索引前缀可以让索引变小变快,但是不能用于排序~分组,也不能用于覆盖索引.
索引前缀的场景: 16进制的ID,比如sessionId.索引变小变快了.

### Multicolumn Indexes
多列经常犯的错: 单独索引很多字段;索引错误顺序的字段
为where子句出现的字段创建索引. 这句话是错误的,如果不能设计3星索引(2星),最好无视where子句,创建覆盖索引去优化.
单独的多个列索引,大多数情况不会改善性能.在OR和AND的情况下,会各自走索引,最后再index merge(or-union,or-intersection).
index merge有时很有用,但大多数是poorly index的指示器.
- intersecting indexes时(and), 你实际只需要一个索引
- union indexes时(or), 算法缓存,排序~归并使用很多CPU和内存
- 有时候过度索引,可能还不如单表扫描.

### Choosing a Good Column Order
小心选择索引顺序,使得行是排列和分组好的,可以有益于查询.
索引是按最左边的字段,再往右.所以正序或逆序在query, order by, group by和distinct被使用.
把选择性最大的列放在最左边. 有些情况有用,但是避免不了random IO,排序.
这条建议确实优化where查询,但还要看实际值的分布(index prefix).
因为用索引前缀,问题经常来自于特殊的值(有更高的独特性).比如: 匿名用户sessionId.
这些建议确实有用,但是不能假设所有的情况都是平均情况,特殊情况可能降低整个应用的性能.

### Clustered Indexes
Clustered indexes?
advantages and disadvantages?

集群索引不是所有类型,而是存储数据的方式.InnoDB存储B-tree索引和行.
行存储在集群索引的叶子页,相邻的键都存储紧挨着.一张表只能有一个集群索引,因为一次性不能存储到两个地方.
集群索引非叶子节点只存储索引列,叶子节点则存储行.
InnoDB默认用主键来集群索引.
没有主键,集群索引就用唯一键,没有唯一键就使用隐藏键.隐藏键是所有表共用的,容易稀疏.
优点:
1. 集群索引把相关数据存储在一起.比如 拿一个用户的消息数据,只用访问几个页,而不是所有的页都访问.
2. 快,因为集群索引索引和行在一起.
3. 查询可以使用主键(在叶子页)key values
--------
缺点:
1. 当数据在内存里,顺序不重要,集群索引没有好处.
2. 插入速度取决于插入的顺序,最好插入前让数据按主键顺序排列.
3. 更新集群索引损耗大,因为必须把每行移动到新的位置.
4. 分页问题.当一行新增到一个满页,满页必须分页.会造成一个表用更多空间.
5. 集群表可能比全表扫描要慢,尤其是行很稀疏(因为分页)
6. 第二索引会比较大,因为leaf节点包括了行的主键key value.
7. 第二索引访问要求查询两个索引而不是一个. Adaptive hash index(帮助减少) 
#### InnoDB's data layout
cluster index: 顺序存储数据,B树,叶子节点存储整行.
secondary index: 存储索引列,B树,叶子节点存储索引列和主键key value.

#### Inserting rows in primary key order with InnoDB
如果不需要特殊的集群索引,直接用自增主键.行就会被顺序插入,并且提供更好的性能.
避免是随机和大量分布的主键,比如UUID,会造成插入随机.
UUID的缺陷:
- 目标页可能被清洗,缓存也被清洗.会造成大量的随机IO.
- 插入不是顺序的,会造成大量分页.
- 页变得稀疏.

### Covering Indexes
where的字段加索引仅仅只是一部分,还有种情况: 查询时直接通过索引找出数,只有B-tree可以做到.
- Index 通过比完整行要少,放内存里也更小
- Index按顺序存储数据,IO更少
- 尤其对于集群索引,可以直接访问数据,不需要再走一遍集群索引.
如果只查索引,不查行, explain Extra:Using index.
什么情况下只查索引,不查行: 只select主键+索引列.

### Using Index Scans for Sorts
当排序走索引时,explain可以看到: type: index.
扫描索引很快,但是如果索引没有cover query, 就会取找索引的每一行,这种就是random IO,会比普通的顺序IO更慢.
排序用索引: 1. order by的排序字段都是索引字段. 2. 索引字段都是同一个方向(都是升序或者降序)
只有一种情况,当最左边是固定值时,仍然会走联合索引.

### Redundant and Duplicate Indexes
MySQL允许重复索引,会分开维护,查询时也会都走索引.造成性能和空间的损耗.
应该删除重复索引.
主键默认会建唯一限制+索引.
冗余索引: 已经有(A,B),(A)就是冗余索引. 只有B树有冗余索引,全文索引没有冗余索引.
已经有(A)了,又加个(A,B)索引.或者(A,ID),因为ID是主键本来就有.
最好是继承索引,而不是增加索引.但是继承索引会使得速度稍慢,索引更大.
最简单的法子就是删除掉冗余和重复索引,可以直接用pt-duplicate-key-checker找出它们.
(A)->(A,B): where A =5 order by id.会使用filesort.

### Unused Indexes
select * from sys.schema_unused_indexes;

## Index and Table Maintenance
维护表的三目标:
1. 找到~修复腐败
2. 维护正确的索引统计数据
3. 减少碎片化

### Finding and Repairing Table Corruption
索引腐败因为Mysql或操作系统的情况非常少.
腐败索引返回错误结果(比如重复主键,甚至锁定和宕机).CHECK TABLE命令可以看表是否腐败.
REPAIR TABLE命令可以修复表.
腐败一般是内存错误,磁盘错误,或者移动MySQL文件错误,不太可能是引擎错误.备份下,不要再查询,会继续腐败数据.
出现腐败,不要只修数据,要找原因.

### Updating Index Statistics
当优化器不知道多少行要查,查询计划太复杂不知道多少行匹配,优化器会用索引统计数据去预估行数.analyze table会重新统计.
-- 重新统计表(索引部分)
analyze table userinfo;
-- cardinality of indexes,多少个不同的值在索引
show index from actor;
select * from information_schema.STATISTICS
where TABLE_NAME = 'actor';
show table status;

### Reducing Index and Data Fragmentation
碎片索引没有放好,在磁盘上也不是序列化的.
碎片索引不是bug,但是范围扫描和全索引扫描会慢几倍.
- Row fragmentation: 行碎片.行存储分散
- Intra-row fragmentation: 行内部碎片.逻辑序列页或行没有顺序存储在磁盘上.
- Free space fragmentation: 空间碎片.分页很多空白.
可以运行Optimize table, 或者dump然后reload数据.

## Summary
访问数据搭配索引,非常影响数据访问.
一般索引指B-tree,特殊索引有特殊用法,非常明显.
- 单行查询非常慢.读一块数据但只返回一行,不如读一块数据返回一批.
- 访问范围数据比较快. 1. 顺序IO不需要查磁盘. 2. 不需要再排序
- Index-only 访问很快, 不需要再去查行.
选择索引和查询避免单行查询,使用内置的排序避免排序操作,利用Index-only Access.对应3-star法则.
place most selective columns first in multicolumn indexes. you Should index all columns in the where clause
如果查询没有受益于索引,考虑更好的索引,或者重写查询.
# 7 Indexing for High Performance
索引是存储引擎用来快速找行的数据结构.
数据量小没有索引也很快,数据量一大性能迅速下降.差索引是现实中首要的性能问题的原因.
索引优化会提升性能,但是需要你重写查询.所以本章和下章关联.

## Indexing Basics
Types of indexes? B-tree(Adaptive hash index), full-text indexes
Benefits of Indexes? navigate, order up, group by, index only queries

书找主题: 直接去索引页找相应的页码.
MySQL先在索引找这个值,通过索引找到对应的行.
索引只会在找最左边的值较为高效,所以涉及到多个字段的,字段的顺序很重要.两个字段单独索引,和两字段联合索引很不相同.

### Types of Indexes
有很多索引类型,同一种类型不同引擎可能实现方式都不一样.
#### B-tree indexes
MySQL使用B-tree创建索引.
B-tree:所有值都是顺序存储,所有的leaf页和Root的距离都是相同的.
B-tree之所以快,因为不用全表扫,对数级别找到包含这个值的node,然后从node开始找.
树的深度取决于表的大小.
因为B-trees按顺序存储数据,所以找范围数据非常有用.比如: 搜索K打头的名字.

##### Adaptive hash index
如果某个值经常被查找,会创建hash表,存储这个值和相应的位置.(类似缓存)

##### Types of queries that can use a B-tree index
B-tree索引在找全值~找范围值~找左前缀效果很好.
以people表为例: key(last_name, first_name, dob)
- Match the full value(全值匹配): 
    Cuba,Allen,1960-01-01
- Match a leftmost prefix(最左前缀匹配):
    Allen(last_name)
- Match a column prefix(第一字段前缀): 
    J%(last_name)
- Match a range of values(第一字段范围匹配): 
    between Allen and Barrymore(last_name)
- Match one part exactly and match a range on another part(第一匹配,第二范围):
    Allen(last_name), K%(range)
- Index-only queries: 只查索引页
因为B-tree是有序的,所以c查找排序都有用.
B-tree indexes的限制: 
- first name为Bill~dob为特定值的,因为不是最左边的字段; last name以z结尾的也不走索引.(这两者全索引查询)
- 如果ABC索引,只有AC的值,那么只会用索引的A字段,不会用C字段.
- 涉及右模糊查询不会优化. where last_name = 'Smith' and first_name like 'J%' and dob = '1980-01-01'.
  索引只会用前两个字段的.

#### Full-text indexes
全文索引用的是分词而不是全文,有很多处理: 复数~布尔等等.
full-text不会取消B-tree索引.全文索引用于match而不是where.
### Benefits of Indexes
B树把数据按有序的方式组织起来,query~order by~group by都受益.Index还会存储值的副本,所以有些值直接在索引可以拿到.
三大好处:
1. Indexes减少server要检查的数据量
2. Indexes避免server sorting和创建临时表
3. Indexes把随机IO转换成序列IO
----
index 3星法则:
1. 索引把相关的行放在一起adjacent
2. 索引的排序是查询所需要的
3. 索引包括查询的所有字段

## Indexing Strategies for High Performance
index strategies?

根据特殊的场景去创建索引来优化性能,这是需要一直学习的技能.

### Prefix Indexes and Index Selectivity
只索引前缀一般要好于索引全值.选择性(索引值数/总行数),从1/#T to 1.
前缀的选择性已经足够好了,当BLOB和text必须索引前缀,因为MySQL不允许索引全值.
索引前缀要做到有足够的选择性(接近索引整合),又不至于太长来节约空间.
用平均selectivity有坑,有可能有非常不平均的数据(某些前缀值特别多).
索引前缀可以让索引变小变快,但是不能用于order by~group by,也不能用于covering indexes.
索引前缀的场景: 16进制的ID,比如sessionId.索引变小变快了.

example1: 根据前缀来索引字段
1. 找出每个值出现次数
    select count(*) as c, city from city_demo group by city order by c desc limit 10;
2. 找出值前缀出现的次数,不断增加前缀长度直到出现次数接近
    select count(*) as c, left(city, 3) as pref from city_demo group by pref order by c desc limit 10;
------------
example2: 根据前缀来索引字段
1. 找整体出现的selectivity
    select count(distinct city) / count(*) as sel0 from city_demo;
2. 找出前缀的selectivity,不断增长长度直到两位有效数字
   select count(distinct left(city, 3)) / count(*) as sel3,
     count(distinct left(city, 4)) / count(*) as sel4 from city_demo;

### Multicolumn Indexes
多列经常犯的错: 单独索引很多字段;索引错误顺序的字段
"为where子句出现的字段创建索引." 这句话是非常错误的,这样只对查询有效.如果不能三星,那么最好无视where,注意行的顺序或者covering indexes.
单独的多个列索引,大多数情况不会改善性能.在OR和AND的情况下,会各自走索引,最后再index merge(or-union,or-intersection).
index merge有时很有用,但大多数是poorly index的指示器.
- intersecting indexes时(and), 你实际只需要一个索引
- union indexes时(or), 算法缓存,排序~归并使用很多CPU和内存,尤其是selective不是很好的时候.
- 优化器不优化这种问题,有时候考虑用union.有时候过度索引,可能还不如单表扫描.
当多个索引时,会有index merge的情况,这个时候可以考虑只用一个索引.
select * from table ignore index(idx_col1) where col1 = 1 and col2 = 2;

### Choosing a Good Column Order
小心选择索引顺序,使得行是排列和分组好的,可以有益于查询.
索引是按最左边的字段,再往右.所以正序或逆序在query, order by, group by和distinct被使用.
"把选择性最大的列放在最左边." 有些情况有用,但是避免不了random IO,排序.
这条建议只能优化where查询,但还要看实际值的分布(index prefix),固定字段A的值,固定字段B有多少.
使用selectivity要注意特殊的值.因为用索引前缀,问题经常来自于特殊的值(有更高的独特性).比如: 匿名用户sessionId.
这些建议确实有用,但是不能假设所有的情况都是平均情况,特殊情况可能降低整个应用的性能.

:wusd
1. 小心选择索引排序顺序,会影响order by和group by.
2. leftmost原则,在query,order by,group by和distinct都会被使用
3. "选择性最大的列放左边". 只对where有用,还需要看(A~B)的组合情况.
4. selectivity优先考虑平均值,但是要注意排除特殊情况.比如: 匿名用户sessionId,某个userId是系统的userId.
5. 平均情况代替不了特殊情况,但特殊情况可能搞崩整个系统.

### Clustered Indexes
Clustered indexes?
advantages and disadvantages?

集群索引: InnoDB用B-tree索引把行存在一起.
行存储在集群索引的叶子页,相邻的键都存储紧挨着.一张表只能有一个集群索引,因为一次性不能存储到两个地方.
集群索引非叶子节点只存储索引列,叶子节点则存储行.
InnoDB默认用主键来集群索引.
没有主键,集群索引就用唯一键,没有唯一键就使用隐藏键.隐藏键是所有表共用的,容易稀疏.
优点:
1. 集群索引把相关数据存储在一起.比如 拿一个用户的消息数据,只用访问几个页,而不是所有的页都访问.
2. 快,因为集群索引索引和行在一起.
3. covering index可以用clustering index的leaf节点数据
--------
缺点:
1. 当数据在内存里,顺序不重要,集群索引没有好处.
2. 插入速度取决于插入的顺序,最好插入前让数据按主键顺序排列.
  如果不按主键插入大量数据,可以optimize table.
3. 更换集群索引字段损耗大,因为必须移动行到新的位置.
4. 分页问题.当一行新增到一个满页,满页必须分页.会造成一个表用更多空间.
5. 集群表可能比全表扫描要慢,尤其是行很稀疏(因为分页)
6. 第二索引会比较大,因为leaf节点包括了行的主键key value.
7. 第二索引访问要求查询两个索引而不是一个. Adaptive hash index(帮助减少) 
#### InnoDB's data layout
cluster index: 顺序存储数据,B树,叶子节点存储整行.
secondary index: 存储索引列,B树,叶子节点存储索引列和主键key.

#### Inserting rows in primary key order with InnoDB
如果不需要特殊的集群索引,直接用自增主键.行就会被顺序插入,并且提供更好的性能.
避免是随机和大量分布的主键,比如UUID,会造成插入随机.
用UUID而不是自增主键,慢的原因:一部分是键本身空间更大,另一方面是分页和碎片化.
UUID的缺陷:
- 目标页可能被移除,缓存也被移除.会造成大量的随机IO.
- 插入不是顺序的,会造成大量分页.
- 数据碎片化.

### Covering Indexes
where的字段加索引仅仅只是一部分,还有种情况: 查询时直接通过索引找出值,只有B-tree可以做到.
- Index 通过比完整行要少,缓存放内存里也更小
- Index按顺序存储数据,IO更少
- 尤其对于集群索引,可以直接访问数据,不需要再走一遍集群索引.
如果只查索引,不查行, explain Extra:Using index.
什么情况下只查索引,不查行: 只select主键+索引列.

### Using Index Scans for Sorts
当排序走索引时,explain可以看到: type: index.
扫描索引很快,但是如果索引没有cover query, 就会取找在索引找到的每一行,这种就是random IO,会比普通的顺序IO更慢.
排序用索引: 1. order by的排序字段都是索引字段. 2. 索引字段都是同一个方向(都是升序或者降序)
只有一种情况,当最左边是固定值时,仍然会走联合索引.

### Redundant and Duplicate Indexes
MySQL允许重复索引,会分开维护,查询时也会都走索引.造成性能和空间的损耗.
重复索引,字段~顺序和方向都一样.应该删除重复索引.
主键默认会建唯一限制+索引.
冗余索引: 已经有(A,B),(A)就是冗余索引. 只有B树有冗余索引,全文索引没有冗余索引.
已经有(A)了,又加个(A,B)索引.或者(A,ID),因为ID是主键本来就有.
最好是继承索引,而不是增加索引.但是继承索引会使得速度稍慢,索引更大.
最简单的法子就是删除掉冗余和重复索引,可以直接用pt-duplicate-key-checker找出它们.
(A)->(A,B): where A =5 order by id.(A有索引时,对排序很有帮助)


### Unused Indexes
select * from sys.schema_unused_indexes;

## Index and Table Maintenance
维护表的三目标:
1. 找到~修复腐败
2. 维护正确的索引统计数据
3. 减少碎片化

### Finding and Repairing Table Corruption
索引腐败因为Mysql或操作系统的情况非常少.
腐败索引返回错误结果(比如重复主键,甚至锁定和宕机).CHECK TABLE命令可以看表是否腐败.
REPAIR TABLE命令可以修复腐败的表.
或者保存数据,然后重新导入.
腐败一般是内存错误,磁盘错误,或者移动MySQL文件错误,不太可能是引擎错误.备份下,不要再查询,会继续腐败数据.
出现腐败,不要只修数据,要找原因.

:wusd
索引腐败的原因,硬件错误,操作系统错误,或者移动了MySQL文件(最可能),或者是引擎内部错误.
CHECK TABLE: 可以检查表是否腐败.
REPAIR TABLE: 可以修复腐败的表.或者保存数据,然后重新导入.

### Updating Index Statistics
当优化器不知道多少行要查,查询计划太复杂不知道多少行匹配,优化器会用索引统计数据去预估行数.analyze table会重新统计.
-- 重新统计表(索引部分)
analyze table userinfo;
-- cardinality of indexes,多少个不同的值在索引
show index from actor;
select * from information_schema.STATISTICS
where TABLE_NAME = 'actor';
show table status;
索引的统计数据,是从部分分页取样本,然后估算所有分页的行数.这些数据用于优化器.
统计的时间: 1.第一次打开表, 2. Analyze table 3. 表的尺寸急剧变化.

:wusd
优化器会使用索引统计数据去优化查询.
索引统计数据的时候: 1. 第一次打开表, 2. Analyze table 3. 表的尺寸急剧改变.
查cardinality: show index from userinfo

### Reducing Index and Data Fragmentation
索引碎片可能是没有放置好,或者在磁盘上不是序列化的.
碎片索引不是bug,但是范围扫描和全索引扫描会慢几倍.
- Row fragmentation: 行碎片.行存储分散
- Intra-row fragmentation: 行内部碎片.逻辑序列页或行没有顺序存储在磁盘上.
- Free space fragmentation: 空间碎片.分页很多空白.
可以运行Optimize table, 或者dump然后reload数据.

:wusd
索引碎片不是bug,但是会影响性能,甚至比全表扫描还慢.
三种碎片:
- 行碎片: 一行存储在不同的地方
- 行内部碎片: 行内部存储的顺序和逻辑顺序不一致.
- 空间碎片: 分页很多空白
解决碎片: Optimize table, 或者先dump然后再reload数据

## Summary
访问数据搭配索引,非常影响数据访问.
一般索引指B-tree,特殊索引有特殊用法,非常明显.
- 单行查询非常慢(这里的单行查询,一行行的筛选).读一块数据但只返回一行,不如读一块数据返回一批.
- 访问范围数据比较快. 1. 顺序IO不需要查磁盘. 2. 不需要再排序
- Index-only 访问很快, 不需要再去查行.
选择索引和查询避免单行查询,使用内置的排序避免排序操作,利用Index-only Access.对应3-star法则.
place most selective columns first in multicolumn indexes. you Should index all columns in the where clause
如果查询没有受益于索引,考虑更好的索引,或者重写查询.
# 7 Indexing for High Performance

索引是存储引擎用来快速找行的数据结构.
数据量小没有索引也很快,数据量一大性能迅速下降.差索引是现实中首要的性能问题的原因.
索引优化会提升性能,但是需要你重写查询.所以本章和下章关联.

:wusd
为高性能索引:
最优的索引比好的索引性能高两个数量级.
创建索引需要和查询搭配使用.

## Indexing Basics

Types of indexes? B-tree(Adaptive hash index), full-text indexes
Benefits of Indexes? navigate, order up, group by, index only queries

书找主题: 直接去索引页找相应的页码.
MySQL先在索引找这个值,通过索引找到对应的行.
索引只会在找最左边的值较为高效,所以涉及到多个字段的,字段的顺序很重要.两个字段单独索引,和两字段联合索引很不相同.
:wusd
索引基础:

- 索引: 存储表的几个字段.先在索引里找这个值,索引告诉对应的行
- 因为索引只会找最左字段,所以涉及多个字段时顺序极其重要.

### Types of Indexes

有很多索引类型,同一种类型不同引擎可能实现方式都不一样.

#### B-tree indexes

MySQL使用B-tree创建索引.
B-tree思路:
- 所有值都是顺序存储
- 所有的leaf页和Root的距离都是相等
B-tree之所以快,因为不用全表扫找数据,从根开始找,根据上下边界,最后找到leaf页.
leaf页有数据指针而不是其他页的指针.node页之上还有其他的node页,树的深度取决于表的大小.
因为B-trees按顺序存储数据,所以找范围数据非常有用.比如: 搜索从I到K打头的名字.

```sql
drop table if exists People;
create table People
(
    last_name  varchar(50) not null,
    first_name varchar(50) not null,
    dob        date        not null,
    key(last_name, first_name, dob)
);
```

##### Adaptive hash index

如果某个值经常被查找,会创建hash表,存储这个值和相应的位置.(类似缓存)

##### Types of queries that can use a B-tree index

B-tree索引在找全值~找范围值~找左前缀效果很好.
以people表为例: key(last_name, first_name, dob)

- Match the full value(全值匹配):
  Cuba,Allen,1960-01-01
- Match a leftmost prefix(最左前缀匹配):
  Allen(last_name)
- Match a column prefix(第一字段前缀):
  J%(last_name)
- Match a range of values(第一字段范围匹配):
  between Allen and Barrymore(last_name)
- Match one part exactly and match a range on another part(第一匹配,第二范围):
  Allen(last_name), K%(range)
- Index-only queries: 只查索引页
  因为B-tree是有序的,所以c查找排序都有用.
  B-tree indexes的限制:
- first name为Bill~dob为特定值的,因为不是最左边的字段; last name以z结尾的也不走索引.(这两者全索引查询)
- 如果ABC索引,只有AC的值,那么只会用索引的A字段,不会用C字段.
- 涉及右模糊查询不会优化. where last_name = 'Smith' and first_name like 'J%' and dob = '1980-01-01'.
  索引只会用前两个字段的.

#### Full-text indexes

全文索引用的是分词而不是全文,有很多处理: 复数~布尔等等.
full-text不会取消B-tree索引.全文索引用于match而不是where.

:wusd
索引类型: 索引在引擎内部实现,即便是相同的索引,实现方式可能不同

- B-tree: 天天喊的索引就是B-tree
    + 整体思路: 顺序存储,所有leaf到root的距离相等
    + 数据结构: node页的key指向node页或者leaf页(深度取决于数据),leaf页指向数据行,末尾指向下一个leaf页
    + 查询方式: 从根开始找,根据上下边界,最后找到leaf页
    + hash index: 在B-tree的顶部有hash表,缓存热点数据
    + 使用B-tree索引的场景: key(last_name, first_name, dob)
        - 全值匹配: Cuba,Allen,1960-01-01
        - 最左前缀匹配: Allen(last_name)
        - 第一字段前缀: J%(last_name)
        - 范围: between Allen and Barrymore(last_name)
        - 第一匹配,第二范围: Allen(last_name), K%(range)
        - Index-only查询: Covering Index
    + 无法使用索引的场景:
        - 不是第一字段,或者字段后缀
        - 字段不能跳过,比如 Cuba,*,1960-01-01,只会使用last_name的索引
        - 右模糊查询不会优化,where last_name = 'Smith' and first_name like 'J%' and dob = '1980-01-01'.
          dob的索引不会被使用,因为first_name是范围查询
- 全文索引:
    + 分词:对同义词,复数,布尔特殊处理
    + 和BTree无冲突,使用match against而不是where

```sql
drop table if exists fulltext_test;
create table fulltext_test
(
    title varchar(200),
    body  text not null,
    fulltext(title, body)
);
insert into fulltext_test
values ('MySQL', 'MySQL is a relational database management system');
insert into fulltext_test
values ('PostgreSQL', 'PostgreSQL is a relational database management system');
select *
from fulltext_test
where match (title, body) against('relational');
```

### Benefits of Indexes

B树把数据按有序的方式组织起来,query~order by~group by都受益.Index还会存储值的副本,所以有些值直接在索引可以拿到.
三大好处:

1. Indexes减少server要检查的数据量
2. Indexes避免server sorting和创建临时表
3. Indexes把随机IO转换成序列IO

----
index 3星法则:

1. 索引把相关的行放在一起adjacent
2. 索引的排序是查询所需要的
3. 索引包括查询的所有字段

:wusd
索引的好处: 因为数据是排序好的,相关数据放在一起,有部分数据的副本,所以order by~group by都会受益.

1. 索引减少了server要检查的行数
2. 索引避免了server sort和创建临时表
3. 索引把随机IO转成序列IO

------
索引的三星法则:

1. (Cluster Index)索引把相关的行在物理相邻
2. 索引的排序是查询需要的
3. 索引包括查询的所有字段

## Indexing Strategies for High Performance

index strategies?

根据特殊的场景去创建索引来优化性能,这是需要一直学习的技能.
:wusd
有多种特殊优化,决定用什么~什么时候以及效果是需要一直学习的技能.

- 索引前缀
- 多字段索引
- 选择多字段索引的顺序
- 聚簇索引cluster index
- 覆盖索引covering index
- 用索引扫描来排序
- 冗余和重复索引
- 不使用的索引

### Prefix Indexes and Index Selectivity

只索引前缀一般要好于索引全值.选择性(索引值数/总行数),从1/#T to 1.
前缀的选择性已经足够好了,当BLOB和text必须索引前缀,因为MySQL不允许索引全值.
索引前缀要做到有足够的选择性(接近索引整合),又不至于太长来节约空间.
用平均selectivity有坑,有可能有非常不平均的数据(某些前缀值特别多).
索引前缀可以让索引变小变快,但是不能用于order by~group by,也不能用于covering indexes.
索引前缀的场景: 16进制的ID,比如sessionId.索引变小变快了.

example1: 根据前缀来索引字段

1. 找出每个值出现次数
   select count(*) as c, city from city_demo group by city order by c desc limit 10;
2. 找出值前缀出现的次数,不断增加前缀长度直到出现次数接近
   select count(*) as c, left(city, 3) as pref from city_demo group by pref order by c desc limit 10;

------------
example2: 根据前缀来索引字段

1. 找整体出现的selectivity
   select count(distinct city) / count(*) as sel0 from city_demo;
2. 找出前缀的selectivity,不断增长长度直到两位有效数字
   select count(distinct left(city, 3)) / count(*) as sel3,
   count(distinct left(city, 4)) / count(*) as sel4 from city_demo;

:wusd
索引前缀和索引选择性:

- 太短则影响选择性,太长则占空间影响性能
- BLOB和TEXT必须索引前缀
- 坏处: 不能用于order by~group by~covering indexes
- 应用: session_id, uuid只索引前缀,速度快很多
- 索引前缀的判断方法
    + 根据前缀前十判断selectivity
    + 根据平均值判断selectivity: 这里有致命缺陷,因为有那种特殊情况,比如城市很多San,New打头的

```sql
drop table if exists city_demo;
create table city_demo
(
    city varchar(50) not null
);
insert into city_demo(city)
select city
from city;
-- repeat 5 times
insert into city_demo(city)
select city
from city_demo;
update city_demo
set city = (select city from city order by rand() limit 1);
-- 找出最常出现的cities, 48~72
select count(*) c, city
from city_demo
group by city
order by c desc limit 10;
-- 找出最常出现的city3前缀,136-440选择性不够
select count(*) c, left (city, 3) pref
from city_demo
group by pref
order by c desc limit 10;
-- 7前缀,比较接近
select count(*) c, left (city, 7) pref
from city_demo
group by pref
order by c desc limit 10;
-- 求整体选择性平均值: 0.0312
select count(distinct city) / count(*)
from city_demo;
-- 求前缀选择性平均值: 
select count(distinct left (city, 3)) / count(*) as sel3,
       count(distinct left (city, 4)) / count(*) as sel4,
       count(distinct left (city, 5)) / count(*) as sel5,
       count(distinct left (city, 6)) / count(*) as sel6,
       count(distinct left (city, 7)) / count(*) as sel7
from city_demo;
```

### Multicolumn Indexes

多字段索引经常犯的错: 单独索引很多字段;索引错误顺序的字段
"where出现字段建索引",只对查询有效,所以是错误的.如果不能三星索引,那么忽略where,注意优化行的顺序或者covering index.
对多个字段单独索引,在or或and条件下,会同时走索引,最后再index merge,所以大多数情况下性能不好.
index merge有时很有用,但大多数是poorly index的指示器.

- intersecting indexes时(and), 你实际只需要一个索引
- union indexes时(or), 算法缓存,排序~归并使用很多CPU和内存,尤其是selective不是很好的时候.
- 优化器不优化这种问题,有时候考虑用union.有时候过度索引,可能还不如单表扫描.
  当多个索引时,会有index merge的情况,这个时候可以考虑只用一个索引.
  select * from table ignore index(idx_col1) where col1 = 1 and col2 = 2;

:wusd
多字段索引:

- 常犯错误:
    + 单独索引许多字段: 会同时走索引,最后再index merge,性能并不好
  ```sql
    --  Extra: union(primary, idx_fk_film_id)
    explain select film_id, actor_id from film_actor where actor_id = 1 or film_id = 1;
  ```
  index merge: AND取交集,OR取并集,优化器不会把这个记入cost,会导致比整表扫描还要慢.
    + 索引错误顺序的字段

### Choosing a Good Column Order

多字段索引,必须考虑各个字段的顺序,有助于查询的排列和分组.
因为索引先根据最左字段排序,再根据第二左字段排序...,因此在order by, group by和distinct,顺序正确才会最大化利用.
"把选择性最大的列放在最左边." 有用但没那么有用,避免不了随机IO,排序.
这条建议只能优化where查询,但还要看实际值的分布(index prefix),固定字段A的值,固定字段B有多少.
使用selectivity要注意特殊的值.因为用索引前缀,问题经常来自于特殊的值(有更高的独特性).比如: 匿名用户sessionId.
这些建议确实有用,但是不能假设所有的情况都是平均情况,特殊情况可能降低整个应用的性能.

:wusd

1. 小心选择索引排序顺序,会影响order by和group by.
2. leftmost原则,在query,order by,group by和distinct都会被使用
3. "选择性最大的列放左边". 部分时候有用,但更应该考虑最左字段的实际分布情况
4. selectivity优先考虑平均值,但是要注意排除特殊情况.比如: 匿名用户sessionId,某个userId是系统的userId.
5. 平均情况代替不了特殊情况,但特殊情况可能搞崩整个系统.

:wusd
选择好的索引排序:

1. 索引从左到右按字段排序,所以字段的排序方向在query~order by~group by和distinct都会按这个利用.
1. "选择性最大的字段放最左边":大部分好用,但是有可能有特殊情况搞崩系统
    - 选择特殊where限制要谨慎,一般要选择整体的选择性
    - 还需要考虑特殊情况,eg. 匿名用户sessionId, 某个userId是系统用户

```sql
-- 是否要加索引(staff_id,customer_id),要不要改变顺序
select *
from payment
where staff_id = 2
  and customer_id = 584;
-- 查分布: 7990, 30
select sum(staff_id = 2), sum(customer_id = 584)
from payment;
-- 查组合分布: 17,特殊条件下的数量
select sum(staff_id = 2)
from payment
where customer_id = 584;
-- 如果有特殊样本去用,那么可以用上面的方法,如果没有的话,最好取平均值
-- 两个字段的selectivity
select count(distinct staff_id) / count(*)    as staff_id_selectivity,
       count(distinct customer_id) / count(*) as customer_id_selectivity,
       count(*)
from payment;
alter table payment
    add key(customer_id, staff_id);
```

```sql
-- type: ref
explain
select count(distinct threadId) as count_value
from message
where groupId = 10137
  and userId = 1288826
  and anonymous = 0
order by priority desc, modifiedDate desc;
-- count(*): 4142217, sum(groupId=10137): 4092654, sum(userId=1288826): 1288496, sum(anonymous=0) 4141934 
select count(*), sum(groupId = 10137), sum(userId = 1288826), sum(anonymous = 0) 4141934
from message;
-- userId=1288826总共有1.3million
```

### Clustered Indexes 我要optimize营房库

Clustered indexes?
advantages and disadvantages?

聚簇索引: InnoDB用B-tree索引把行存在一起.
相邻的行紧挨着存储在聚簇索引的叶子页,一张表只有一个聚簇索引,因为行只能存在一个地方.
InnoDB用主键来创建聚簇索引,如果没有主键,就用隐藏所有表自增主键聚簇索引,容易存储稀疏.
优点:

1. 集群索引把相关数据存储在一起.比如 拿一个用户的消息数据,只用访问几个页,而不是所有的页都访问.
2. 比普通索引快,因为集群索引索引和行在一起.
3. covering index可以用clustering index的leaf节点数据

--------
缺点:

1. 当数据在内存里,顺序不重要,集群索引没有好处.
2. 插入速度取决于插入的顺序,最好插入前让数据按主键顺序排列.
   如果不按主键插入大量数据,可以optimize table.
3. 更换集群索引字段损耗大,因为必须移动行到新的位置.
4. 分页问题.当一行新增到一个满页,满页必须分页.会造成一个表用更多空间.
5. 集群表可能比全表扫描要慢,尤其是行很稀疏(因为分页)
6. 第二索引会比较大,因为leaf节点包括了行的主键key value.
7. 第二索引访问要求查询两个索引而不是一个. Adaptive hash index(帮助减少)

:wusd
聚簇索引:

- 聚簇索引: 数据结构是B-Tree,相邻的行紧挨着存储在叶子页; 一张表只有一个聚簇索引,因为行只能存在一个地方
- InnoDB默认用主键聚簇索引,如果没有主键,就用隐藏自增主键聚簇索引,容易存储稀疏.
- 优点:
    1. 相关数据存储在一起,比如: 拿一个用户的消息数据,只用访问几个页,而不是所有的页都访问.
    2. 比普通索引快,因为集群索引索引和行在一起
    3. covering index可以使用主键值
- 缺点:
    1. 数据在内存时,没有顺序存储的好处
    2. 插入速度取决于插入顺序
       插入前让数据按主键顺序排列; 大量插入乱序数据,可以optimize table!!!!
    3. 修改主键值,代价大,必须移动行到新的位置
    4. 插入时数据时,如果页慢了,会产生分页问题
    5. 聚簇表可能比全表扫描要慢,尤其是行很稀疏(因为分页)
    6. 第二索引较大,因为leaf节点还包含行的主键
    7. 第二索引访问需要查两个索引. Adaptive Hash Index(帮助减少)

#### InnoDB's data layout

cluster index: 顺序存储数据,B树,叶子节点存储整行.
secondary index: 存储索引列,B树,叶子节点存储索引列和主键key.

:wusd
InnoDB数据布置:
有聚簇索引时,第二索引存储聚簇索引的主键,而不是指针.
坏处是空间占用比之前大,好处是移动行时,不需要更新第二索引的指针.

#### Inserting rows in primary key order with InnoDB

如果不需要特殊的集群索引,直接用自增主键.行就会被顺序插入,并且提供更好的性能.
避免是随机和大量分布的主键,比如UUID,会造成插入随机.
用UUID而不是自增主键,慢的原因:一部分是键本身空间更大,另一方面是分页和碎片化.
UUID的缺陷:

- 目标页可能被移除,缓存也被移除.会造成大量的随机IO.
- 插入不是顺序的,会造成大量分页.
- 数据碎片化.

:wusd
按主键顺序插入行:

1. 递增地插入数据: 直接自增主键,行会顺序插入,这样性能好
2. 随机主键: eg.UUID
    - 键值占用空间大
    - 大量分页和碎片化
    - 目标页被刷入磁盘,被移除缓存,造成大量随机IO(因为缓存页码有限,随机页码导致无法缓存)

### Covering Indexes

"where的字段加索引",仅仅只是一部分,还有覆盖索引的情况.

- Index 通常比完整行要少,缓存放内存里也更小
- Index按顺序存储数据,IO更少
- 因为有聚簇索引,第二索引存储主键,所以涉及查询主键时不需要再次查询.
  如何判断是否covering Index, explain Extra:Using index.

 ```sql
-- Covering Index Explain, Extra: Using index
explain
select store_id, film_id
from inventory;
-- Covering index 包括主键
explain
select actor_id, last_name
from actor
where last_name = 'HOPPER';
```

什么情况下只查索引,不查行: 只select主键+索引列.

:wusd
覆盖索引: 查询时只查索引不回表

- 什么情况下覆盖索引: 只select主键+索引列.
- 如何判断是否covering Index, explain [SQL] Extra:Using index.
- 优点:
    - 索引比行小,所以缓存更小
    - 顺序存储数据,IO次数更少
    - 因为存储聚簇索引的主键,所以涉及主键时,不需要再次查询

### Using Index Scans for Sorts

排序有两种:索引排序,操作排序. 索引排序时,explain可以看到: type: index.
Covering index用索引排序很快,但是如果没有时,就需要取找索引对应的每一行.这种是random IO,比全表扫描还慢.
排序用索引:

1. order by的排序字段都是索引字段.
2. 索引字段都是同一个方向(都是升序或者降序)
3. 连表时,只有第一个表的字段有效
4. 最左原则,只有一种情况,当最左边是固定值时,仍然会走联合索引.

```sql
-- 索引情况: 主键(rental_id),unique rental_date(rental_date,inventory_id,customer_id), 
--          (inventory_id),(customer_id),(staff_id)
-- Extra: 没有filesort,使用了索引排序,因为rental_datew为常量,(rental_date,inventory_id,customer_id)覆盖了查询
explain
select rental_id, staff_id
from rental
where rental_date = '2005-05-25'
order by inventory_id, customer_id;
```

:wusd
索引排序:

- 如何判断是否索引排序? explain [SQL] Extra:没有filesort, 且 type: ref/index
- 当索引没有覆盖查询时,需要回表,索引排序比全表扫描更慢(MySQL8直接filesort)
- 索引排序情况:
    - order by的字段都是索引字段
    - 索引字段都是同一方向(升序或降序)
    - 连表时,order by只能有第一个表的字段
    - 索引字段最左原则,只有一种情况,当最左边是固定值时,仍然会走联合索引
- 具体情况看下面的SQL
```sql
-- 索引情况: 主键(rental_id),rental_date(rental_date,inventory_id,customer_id),
--          (inventory_id),(customer_id),(staff_id)
----------------------------索引排序
-- 索引最左原则的特例(第一字段为常量)
-- 索引排序: 最左字段是常量,其他为索引字段
explain
select rental_id, staff_id
from rental
where rental_date = '2005-05-25'
order by inventory_id, customer_id;
-- 索引排序: 最左字段常量,其他为索引字段
explain
select rental_id, staff_id
from rental
where rental_date = '2005-05-25'
order by inventory_id desc;
-- 索引排序(需强制使用索引): 最左范围,其他字段索引
explain
select rental_id, staff_id
from rental force index for order by(rental_date)
where rental_date > '2005-05-25' 
order by rental_date, inventory_id;
----------------------------操作排序
-- 操作排序: 字段排序方向不一致
explain
select rental_id, staff_id
from rental
where rental_date = '2005-05-25'
order by inventory_id desc, customer_id asc;
-- 操作排序: 字段有非索引字段
explain
select rental_id, staff_id
from rental
where rental_date = '2005-05-25'
order by inventory_id , staff_id;
-- 操作排序: 字段不是最左字段
explain
select rental_id, staff_id
from rental
where rental_date = '2005-05-25'
order by customer_id;
-- 操作排序: 排序第一字段不是最左字段,where最左字段是range
explain
select rental_id, staff_id
from rental
where rental_date > '2005-05-25'
order by inventory_id, customer_id;
-- 操作排序: 第二字段不是常量,而是range
explain
select rental_id, staff_id
from rental
where rental_date = '2005-05-25'
and inventory_id in (1, 2)
order by customer_id;
-- 理论上索引排序,实际上操作排序;因为优化器把film_actor当作第二张表
explain select actor_id, title from film_actor
inner join film using(film_id) order by actor_id;
```

### Redundant and Duplicate Indexes

MySQL允许重复索引,会分开维护,查询时也会都走索引.造成性能和空间的损耗.
重复索引,字段~顺序和方向都一样.应该删除重复索引.
主键默认会建唯一限制+索引.
冗余索引: 已经有(A,B),(A)就是冗余索引. 只有B树有冗余索引,全文索引没有冗余索引.
已经有(A)了,又加个(A,B)索引.或者(A,ID),因为ID是主键本来就有.
最好是继承索引,而不是增加索引.但是继承索引会使得速度稍慢,索引更大.
最简单的法子就是删除掉冗余和重复索引,可以直接用pt-duplicate-key-checker找出它们.
(A)->(A,B): where A =5 order by id.(A有索引时,对排序很有帮助)

### Unused Indexes

select * from sys.schema_unused_indexes;

## Index and Table Maintenance

维护表的三目标:

1. 找到~修复腐败
2. 维护正确的索引统计数据
3. 减少碎片化

### Finding and Repairing Table Corruption

索引腐败因为Mysql或操作系统的情况非常少.
腐败索引返回错误结果(比如重复主键,甚至锁定和宕机).CHECK TABLE命令可以看表是否腐败.
REPAIR TABLE命令可以修复腐败的表.
或者保存数据,然后重新导入.
腐败一般是内存错误,磁盘错误,或者移动MySQL文件错误,不太可能是引擎错误.备份下,不要再查询,会继续腐败数据.
出现腐败,不要只修数据,要找原因.

:wusd
索引腐败的原因,硬件错误,操作系统错误,或者移动了MySQL文件(最可能),或者是引擎内部错误.
CHECK TABLE: 可以检查表是否腐败.
REPAIR TABLE: 可以修复腐败的表.或者保存数据,然后重新导入.

### Updating Index Statistics

当优化器不知道多少行要查,查询计划太复杂不知道多少行匹配,优化器会用索引统计数据去预估行数.analyze table会重新统计.
-- 重新统计表(索引部分)
analyze table userinfo;
-- cardinality of indexes,多少个不同的值在索引
show index from actor;
select * from information_schema.STATISTICS
where TABLE_NAME = 'actor';
show table status;
索引的统计数据,是从部分分页取样本,然后估算所有分页的行数.这些数据用于优化器.
统计的时间: 1.第一次打开表, 2. Analyze table 3. 表的尺寸急剧变化.

:wusd
优化器会使用索引统计数据去优化查询.
索引统计数据的时候: 1. 第一次打开表, 2. Analyze table 3. 表的尺寸急剧改变.
查cardinality: show index from userinfo

### Reducing Index and Data Fragmentation

索引碎片可能是没有放置好,或者在磁盘上不是序列化的.
碎片索引不是bug,但是范围扫描和全索引扫描会慢几倍.

- Row fragmentation: 行碎片.行存储分散
- Intra-row fragmentation: 行内部碎片.逻辑序列页或行没有顺序存储在磁盘上.
- Free space fragmentation: 空间碎片.分页很多空白.
  可以运行Optimize table, 或者dump然后reload数据.

:wusd
索引碎片不是bug,但是会影响性能,甚至比全表扫描还慢.
三种碎片:

- 行碎片: 一行存储在不同的地方
- 行内部碎片: 行内部存储的顺序和逻辑顺序不一致.
- 空间碎片: 分页很多空白
  解决碎片: Optimize table, 或者先dump然后再reload数据

## Summary

访问数据搭配索引,非常影响数据访问.
一般索引指B-tree,特殊索引有特殊用法,非常明显.

- 单行查询非常慢(这里的单行查询,一行行的筛选).读一块数据但只返回一行,不如读一块数据返回一批.
- 访问范围数据比较快. 1. 顺序IO不需要查磁盘. 2. 不需要再排序
- Index-only 访问很快, 不需要再去查行.
  选择索引和查询避免单行查询,使用内置的排序避免排序操作,利用Index-only Access.对应3-star法则.
  place most selective columns first in multicolumn indexes. you Should index all columns in the where clause
  如果查询没有受益于索引,考虑更好的索引,或者重写查询.